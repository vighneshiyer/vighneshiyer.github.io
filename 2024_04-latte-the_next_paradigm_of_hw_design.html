<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Chisel/Chipyard Demo + The Next Paradigm of SoC Design</title>
    <meta name="description" content="">
    <meta name="author" content="Joonho Whangbo, Vighnesh Iyer">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
.reveal table.old_paradigm_table {
  width: 100%;
  font-size: 60%;
  border-collapse: separate;
  border-spacing: 0.1rem;
  margin-bottom: 1rem;
  tr > th {
    text-align:center;
    border: none;
  }
  tr > td {
      border: 2px solid black !important;
      border-radius: 5px;
  }
  tbody tr td {
      width: 16.6666%;
      height: 1rem;
      text-align: center;
      vertical-align: middle;
  }
  tbody tr th {
      vertical-align: middle;
  }
  tbody tr:nth-child(3) td:nth-child(3) {
  }
}
.reveal table.old_paradigm_table.new.visible {
  border-spacing: 0rem;
  tr > td {
    border-radius: 0;
    border: 0 !important;
  }
  tbody tr:nth-child(1) td {
      background: #34548a !important;
  }
  tbody tr:nth-child(2) td {
      background: #0f4b6e !important;
  }
  tbody tr:nth-child(3) td {
      background: #5a4a78 !important;
  }
}
</style>
    <script type="module" crossorigin src="/assets/2024_04-latte-the_next_paradigm_of_hw_design-DkZgnWSZ.js"></script>
    <link rel="modulepreload" crossorigin href="/assets/reveal.esm-FLSLtKfW.js">
    <link rel="stylesheet" crossorigin href="/assets/reveal-BCbOiT2X.css">
    <link rel="stylesheet" crossorigin href="/assets/2024_04-latte-the_next_paradigm_of_hw_design-CTiOY5hn.css">
    <link rel="stylesheet" crossorigin href="/assets/tokyonight-light-BgAoksBk.css">
  </head>

  <body vocab="http://schema.org/" typeof="PresentationDigitalDocument">
    <span property="publisher" style="display: none;">LATTE 2024</span>
    <time pubdate property="datePublished" datetime="2024-04-29" style="display: none;">April 29, 2024</time>
    <div class="reveal">
        <div class="slides">

<section>
  <section class="center">
    <a href="https://github.com/ucb-bar">
      <img src="/assets/BAR_vertical_logo-CgcBQn4j.svg" class="image" style="height: 100px;">
    </a>
    <a href="https://github.com/ucb-bar/chipyard">
      <img src="/assets/chipyard_logo-BOSErldK.svg" class="image" style="height: 100px;">
    </a>
    <h2 class="fragment">The Next Paradigm of Hardware Design</h2>
    <h3>Chipyard Overview + Calyx Integration Demo</h3>
    <h4 style="font-weight:normal;">
      Joonho Whangbo, Vighnesh Iyer, Sophia Shao, Krste Asanović, Bora Nikolić (UC Berkeley)
    </h4>
    <h5 style="font-weight:normal;">
      LATTE 2024
    </h5>
  </section>
  <section>
    <h2>Talk Overview</h2>
    <ol>
      <li class="fragment">Our vision of the next paradigm of hardware design</li>
      <li class="fragment">The current paradigm and prior work in building the future
        <ul>
          <li class="fragment">New HDLs and design abstractions</li>
          <li class="fragment">New simulators</li>
          <li class="fragment">New SoC design frameworks</li>
        </ul>
      </li>
      <li class="fragment">Berkeley's effort to build the tools for the next paradigm
        <ul>
          <li>Chisel, FIRRTL, Chipyard, FireSim</li>
          <li>Demo of integrating external IP into a Chipyard SoC</li>
        </ul>
      </li>
      <li class="fragment">What's still missing? Why are we not in the new age of hardware design?
        <!--<ul>
          <li>It's a lot more than just the frontend language: PPA iteration cycle, verification, other stuff</li>
        </ul>-->
      </li>
      <li class="fragment">Design considerations for the next generation of hardware design languages and tools</li>
    </ol>
  </section>
</section>

<section>
  <section class="center">
    <h2>The Next Paradigm of Hardware Design</h2>
    <img class="image fragment no-margin" width="50%" src="/assets/new-paradigm-HAG3sSfS.svg" />

    <ol>
      <li class="fragment"><strong class="green">Rapid iteration cycle</strong>: seconds to evaluate a change</li>
      <li class="fragment"><strong class="green">Seamless mixed-abstraction design</strong>: interop enables productivity and a common simulation/VLSI substrate</li>
      <li class="fragment"><strong class="green">Semantics preserving stack</strong>: enrich every design layer with semantics (circuit constructs, power/clock/reset, verification) for better QoR</li>
    </ol>
  </section>

  <!--<section>
    <h2>Flat Organization</h2>

    <table class="old_paradigm_table fragment custom new">
      <thead>
      <tr>
        <th></th>
        <th></th>
        <th colspan="5">Teams within an SoC Design Organization</th>
      </tr>
      <tr style="text-align: center;">
        <th></th>
        <th></th>
        <th>Spec / Arch</th>
        <th>Perf Modeling</th>
        <th>RTL</th>
        <th>DV</th>
        <th>PD</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <th rowspan="3" style="vertical-align: middle;">Design block</th>
        <th>Core</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th>LLC</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th>NPU</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      </tbody>
    </table>

    <ul>
      <li class="fragment">Agile, small, and generalist workforce</li>
      <li class="fragment">Teams are specialized by design block rather than function</li>
      <li>Teams collaborate across functions</li>
      <li class="fragment">Design and specification artifacts are reused and contain semantics that span from specification to PD</li>
      <li class="fragment">Higher level abstractions enable productivity across the stack</li>
    </ul>
  </section>-->

  <!--<section>
    <h2>Main Ideas</h2>
    <dl>
      <dt class="fragment">Frontends</dt>
      <dd class="fragment">Mixed-abstraction, interop semantics, ergonomic external module integration, embedding PD/power/verification collateral, rewrite/spec/compiler generation</dd>
      <dt class="fragment">IRs</dt>
      <dd class="fragment">Preservation of semantics, graph-oriented representation</dd>
      <dt class="fragment">Tools / Simulators</dt>
      <dd class="fragment">Low latency iteration cycle (incremental), full spectrum (from specification to PD)</dd>
    </dl>
  </section>-->
</section>

<section>
  <section class="center">
    <h2>The Current Paradigm of Hardware Design</h2>

    <div class="center fragment">
      <img width="50%" class="image no-margin" src="/assets/current-paradigm-DzqXsLNK.svg" />
    </div>

    <ol>
      <li class="fragment"><strong class="red">Slow iteration cycle</strong>: minutes to hours for evaluating a change</li>
      <li class="fragment"><strong class="red">One abstraction at a time</strong>: coarse-grained integration of multiple design abstractions limits the productivity benefits of each one</li>
      <li class="fragment"><strong class="red">Loss of semantics</strong>: RTL is the "narrow waist" in the stack; higher-level semantics are stripped</li>
    </ol>
  </section>

  <!--<section>
    <h2>Rapid Iteration Across the Design Flow</h2>

    <div class="container image no-padding no-margin" style="grid-template-columns: 1fr 1fr;">
      <div class="fragment"><img width="60%" src="./figs/latte24/livesynth.png" /></div>
      <div class="fragment"><img src="./figs/latte24/livehd.png" /></div>
      <p><em>Modified image of iteration speeds. Make it clear that an fine-grained accuracy vs fidelity tradeoff is possible.</em></p>
    </div>
    <div class="center">
      <figcaption class="fragment small">LiveSynth and LiveHD make strong drive towards rapid iteration.</figcaption>
    </div>

    <ul>
      <li class="fragment">Focus not only on performance (throughput) of existing frontend + simulation tools, but also on <em>startup latency</em></li>
      <li class="fragment">It's a lot more than just the frontend language: PPA evaluation, verification, and simulation is critical</li>
      <li><em>Call out LiveHD, LiveSim, LiveSynth for being the only works that tackle this critical problem</em></li>
    </ul>
  </section>-->

  <section>
    <div style="position: relative;">
    <h2>1. <span class="red">Slow Iteration Cycle</span></h2>
    <img class="image no-margin" style="position:absolute; top: 0; right: 0; transform-origin: top right; transform: scale(1); padding: 0.3rem; width: 20%; z-index: 1;" src="/assets/current-paradigm-DzqXsLNK.svg" />

    <div class="center">
      <img class="image no-margin fragment" style="z-index:-9999;" src="/assets/iteration_speeds-ByM7riZ6.svg" />
      <!--Image of iteration speeds as they exist currently. few minutes from design change to elab (for Chipyard), 10s of minutes for HLS. time for RTL sim + eval. time for firesim fpga eval. time for PD flow for power/area-->
    </div>

    <ul>
      <li class="fragment">Each new layer of tools adds latency from making a change to evaluation</li>
      <li class="fragment">Current generation of tools has ad-hoc support for <em>incremental compilation</em> of the design and simulator
      <ul>
        <li class="fragment"><strong class="green">Progress</strong>: LiveHD<span class="reference">[1]</span>, LiveSynth<span class="reference">[2]</span>, LiveSim<span class="reference">[3]</span>: efforts to make incremental execution and rapid iteration first-class features of the design cycle</li>
      </ul>
      </li>
    </ul>

    <div class="footnote fragment">
    [1] Coffman, Hunter, Kenneth Mayer, Sakshi Garg, and Jose Renau. "A Multi-threaded Fast Hardware Compiler for HDLs." CC’23.<br />
    [2] Possignolo, Rafael Trapani, and Jose Renau. "LiveSynth: Towards an interactive synthesis flow." DAC 2017.<br />
    [3] Skinner, Haven, Rafael Trapani Possignolo, Sheng-Hong Wang, and Jose Renau. "LiveSim: A fast hot reload simulator for HDLs." ISPASS 2020.
    </div>
    </div>
  </section>

  <section>
    <h2>1. <span class="red">Slow Iteration Cycle</span> - <span class="green">New Simulators</span></h2>
    <dl>
      <div class="fragment">
        <dt>Higher-abstraction simulators</dt>
        <dd><a href="https://docs.calyxir.org/debug/cider.html">Cider (Calyx)</a>, <a href="https://people.csail.mit.edu/bthom/asplos21-1.pdf">Cuttlesim (Koika)</a>, <a href="https://github.com/accellera-official/systemc">SystemC</a></dd>
      </div>

      <div class="fragment">
        <dt>RTL SW simulators</dt>
        <dd><a href="https://www.veripool.org/verilator/">Verilator</a>, <a href="https://github.com/circt/arc-tests">Arcilator</a>, <a href="https://yosyshq.readthedocs.io/projects/yosys/en/latest/cmd/write_cxxrtl.html">CXXRTL</a>, <a href="https://github.com/chipsalliance/treadle">Treadle</a>, <a href="https://github.com/ucsc-vama/essent">ESSENT</a>, <a href="https://github.com/ucsc-vama/essent/tree/repcut">RepCut</a>, <a href="https://github.com/pku-liang/ksim/tree/main">Khronos</a></dd>
      </div>

      <div class="fragment">
        <dt>HW accelerated RTL simulators</dt>
        <dd class="small"><strong><a href="https://fires.im/">FireSim</a></strong>, <a href="https://github.com/ManticoreRTL">Manticore</a> (FPGA) | <a href="https://github.com/dian-lun-lin/RTLflow">RTLFlow</a> (GPU) | <a href="https://dl.acm.org/doi/abs/10.1145/3613424.3614257">ASH</a> (ASIC) | <a href="https://arxiv.org/abs/2403.04714">Parendi</a> (Graphcore IPU)</dd>
      </div>
    </dl>

    <hr class="fragment">

    <ol>
      <li class="fragment">Higher-level abstractions ⮕ lower startup latency and higher throughput</li>
      <li class="fragment">Optimize software RTL simulators ⮕ higher throughput
        <ul class="small"><li>Memory layout, SIMD, multicore, step skipping, IR interpreters</li></ul>
      </li>
      <li class="fragment">Leverage specialized hardware ⮕ faster evaluation of long workloads</li>
    </ol>

    <!--These simulators address iteration speed by either simulating higher level abstractions, optimizing simulation kernels, or using specialized hardware.-->
    <!--<p class="center fragment">Iteration speed is critical; simulation is the workhorse of HW design. SW RTL simulation isn't at its limit! HW accelerated RTL simulation has been scantly explored.</p>-->
  </section>

  <section>
    <div style="position:relative;">
    <h2>2. <span class="red">One Abstraction at a Time</a></h2>
    <img class="image no-margin" style="position:absolute; top: 0; right: 0; transform-origin: top right; transform: scale(1); padding: 0.3rem; width: 20%; z-index: 1;" src="/assets/current-paradigm-DzqXsLNK.svg" />

    <div class="container" style="grid-template-columns: 1fr 1fr;">
      <div class="fragment"><img class="image no-margin no-padding" style="padding: 0.3rem;" src="/assets/esp_flow-BMZJ1GSX.png" /></div>
      <div class="fragment">
    <pre><code class="scala" data-trim data-line-numbers>
class GCDMMIOBlackBox(val w: Int)
  extends BlackBox(Map("WIDTH" -> IntParam(w)))
  with HasBlackBoxResource
  with HasGCDIO
{
  addResource("/vsrc/GCDMMIOBlackBox.v")
}
    </code></pre>
      </div>
    </div>

    <ul>
      <li class="fragment">We are still far away from realizing true multi-abstraction interop
        <ul>
        <li class="fragment">Verilog blackboxing is too coarse-grained and means lowering everything to RTL</li>
        <li class="fragment">Designers can benefit from fine-grained interop</li>
        </ul>
      </li>
    </ul>

    <dl>
      <dt class="fragment">Elaboration time interop</dt><dd class="fragment">The practical mechanism (FFI) of invoking sub-generators<span class="reference">[1]</span></dd>
      <dt class="fragment">Runtime interop</dt><dd class="fragment">Runtime interaction semantics between abstractions</dd>
    </dl>

    <div class="footnote fragment">
      [1] Daly, Ross, Lenny Truong, and Pat Hanrahan. "Invoking and linking generators from multiple hardware languages using coreir." WOSET 2018.
    </div>

    </div>
  </section>

  <section>
    <h2 class="no-margin">2. <span class="green">New HDLs and Design Abstractions</span></h2>

    <dl class="smallish">
      <div class="fragment">
        <dt>Intermediate representations</dt>
        <dd class="small">
        <a href="https://github.com/chipsalliance/firrtl-spec">FIRRTL</a>,
        <a href="https://github.com/fabianschuiki/llhd">LLHD</a>,
        <a href="https://circt.llvm.org/docs/Dialects/">Circt</a> <small>(affine, handshake, ssp, pipeline, fsm, dc)</small>,
        <a href="https://dl.acm.org/doi/pdf/10.1145/3623278.3624767">HIR</a>,
        <a href="https://github.com/masc-ucsc/livehd/tree/master/lgraph">LGraph</a>/<a href="https://masc.soe.ucsc.edu/docs/woset19b.pdf">LNAST</a>,
        <a href="https://github.com/YosysHQ/yosys/blob/main/kernel/rtlil.h">Yosys RTLIL</a>,
        <a href="https://dl.acm.org/doi/abs/10.1145/3453483.3454075">Reticle</a>
        </dd>
      </div>
      <div class="fragment">
        <dt>RTL-level</dt>
        <dd class="small">
        <strong><a href="https://www.chisel-lang.org/">Chisel</a></strong>, <a href="https://github.com/SpinalHDL/SpinalHDL?tab=readme-ov-file">SpinalHDL</a> (Scala) |
        <a href="https://ieeexplore.ieee.org/document/1420905">Lava</a>, <a href="https://github.com/blarney-lang/blarney">Blarney</a> (Haskell) |
        <a href="https://github.com/amaranth-lang/amaranth">Amaranth</a>, <a href="https://www.myhdl.org/">MyHDL</a>, <a href="https://github.com/pymtl/pymtl3">PyMTL3</a>, <a href="https://github.com/UCSBarchlab/PyRTL">PyRTL</a>, <a href="https://github.com/phanrahan/magma">Magma</a>, (Python) |
        <a href="https://github.com/janestreet/hardcaml">HardCaml</a> (OCaml) |
        <a href="https://intel.github.io/rohd-website/">ROHD</a> (Dart) |
        <a href="https://github.com/masc-ucsc/pyrope_artifacts">pyrope</a>, <a href="https://github.com/veryl-lang/veryl">Veryl</a> (freestanding)
        </dd>
      </div>
      <div class="fragment">
        <dt>Dataflow</dt>
        <dd>
        <a href="https://spade-lang.org/">Spade</a>,
        <a href="https://github.com/kaist-cp/shakeflow">Shakeflow</a>,
        <a href="https://github.com/DFiantHDL/DFiant">DFiant</a>,
        <a href="https://github.com/JulianKemmerer/PipelineC">PipelineC</a>,
        <a href="https://www.redwoodeda.com/tl-verilog">TL-Verilog</a>
        </dd>
      </div>
      <div class="fragment">
        <dt>Control flow synthesis</dt>
        <dd>
        <a href="https://calyxir.org/">Calyx</a>,
        <a href="https://github.com/google/xls">XLS</a>,
        <a href="https://github.com/B-Lang-org/bsc">Bluespec</a>,
        <a href="https://github.com/mit-plv/koika">Koika</a>,
        <a href="https://clash-lang.org/">Clash</a>
        </dd>
      </div>
      <div class="fragment">
        <dt>Accelerator design languages</dt>
        <dd>
        <a href="https://spatial-lang.org/">Spatial</a>,
        <a href="https://capra.cs.cornell.edu/dahlia/">Dahlia</a>,
        <a href="https://dl.acm.org/doi/abs/10.1145/3352460.3358292">μIR</a>,
        <a href="https://github.com/cornell-zhang/heterocl">HeteroCL</a>,
        <a href="https://arxiv.org/pdf/2404.04815.pdf">Allo</a>
        </dd>
      </div>
      <div class="fragment">
        <dt>General HLS</dt>
        <dd>
        SystemC (<a href="https://eda.sw.siemens.com/en-US/ic/catapult-high-level-synthesis/">Catapult</a>),
        C++ (<a href="http://lightsail.legupcomputing.com/">LegUp</a>, <a href="https://github.com/Xilinx/HLS">Vitis HLS</a>)
        </dd>
      </div>
    </dl>

    <p class="center small fragment"><span class="red">Stack of Perl and macros in SystemVerilog</span> <span class="green">⮕ new RTL-level DSLs</span></p>
    <p class="center fragment"><span class="green">Rich ecosystem of design languages</span> enable higher productivity, but they are <strong class="red">difficult to compose and integrate.</strong></p>
  </section>

  <section>
    <h2>2. <span class="green">New SoC Design Frameworks</span></h2>

    <ul class="fragment">
      <li><strong><a href="https://github.com/ucb-bar/chipyard">Chipyard</a></strong> (Berkeley)<!--: Chisel-based, cores (Rocket, BOOM, CVA6), accelerators (Gemmini, NVDLA), memory system + NoC--></li>
      <li><a href="https://www.esp.cs.columbia.edu/">ESP</a> (Columbia)<!--: Tile based SoC architecture, cores (CVA6, Ibex), accelerators (Verilog blackboxing), memory system + NoC--></li>
      <li><a href="http://parallel.princeton.edu/openpiton/">OpenPiton</a> (Princeton)<!--: Ariane + memory / uncore components--></li>
      <li><a href="https://github.com/pulp-platform/pulp">PULP</a> (ETH Zurich)<!--: Cores (RISCY, zero-riscy), ???--></li>
      <li><a href="https://github.com/black-parrot/black-parrot">BlackParrot</a> (UW)<!--: ???--></li>
      <li><a href="https://github.com/OpenXiangShan/XiangShan">Xiangshan</a> (Chinese Academy of Sciences)<!--: High performance OoO RISC-V core + L2--></li>
    </ul>

    <!--<div class="center fragment">
      <img class="image no-margin" src="./figs/dynamic/latte24/soc_construction.svg" />
      <p><em>Image of Makefile calling other Makefiles and being wrapped in yet another custom build system</em></p>
    </div>-->

    <!-- web of scripts and build systems, config systems on top of config systems -->

    <!--<ul>
      <li class="fragment">Composing IP correctly is hard. Satisfying global constraints, verifying every interface conforms, parameter propagation</li>
      <li class="fragment">SoC construction described in ad-hoc phases with yaml on top of Makefiles on top of Makefiles</li>
      <li class="fragment">Collateral emission at block and SoC level must understand the configuration of every IP</li>
    </ul>-->

    <p class="center fragment">Full system evaluation at <span class="green">RTL-level</span>.</p>
    <p class="center fragment"><span class="green">SoC level parameterization</span><span class="reference">[1]</span> and <span class="orange">integration of external IP</span>.</p>

    <div class="footnote fragment">
      [1] Cook, Henry, Wesley Terpstra, and Yunsup Lee. "Diplomatic design patterns: A TileLink case study." CARRV 2017.
    </div>
  </section>

  <section>
    <div style="position: relative;">
    <h2>3. <span class="red">Loss of Semantics</span></h2>
    <img class="image no-margin" style="position:absolute; top: 0; right: 0; transform-origin: top right; transform: scale(1); padding: 0.3rem; width: 20%; z-index: 1;" src="/assets/current-paradigm-DzqXsLNK.svg" />

    <div class="container" style="grid-template-columns: 1fr 1fr; margin-bottom: 1rem;">
      <div>
        <img data-fragment-index=1 class="fragment image no-margin" src="/assets/simulator_interop-BBOpnYTK.svg" />
      </div>
      <div>
        <img data-fragment-index=3 style="z-index:9999;" class="fragment image no-margin" src="/assets/synthesis_semantics-TBoI80II.svg" />
      </div>
    </div>

    <ul>
      <li class="fragment" data-fragment-index=2>Lack of a common runtime interop model ⮕ hacked together composition / slow iteration</li>
      <li class="fragment" data-fragment-index=4>Existing IRs erase design semantics ⮕ must be recovered by synthesis / simulation tools, lower QoR</li>
    </ul>

    <!--<div class="center fragment">
      <img class="image no-margin" src="./figs/dynamic/latte24/typical_flow.svg" />
      <figcaption class="small">A pretty typical flow</figcaption>
      <p><em>Insert picture of ugly SystemVerilog macros, Perl generators</em></p>
    </div>-->

    <!--
    - ill defined / complex semantics, mixing simulation and synthesizable abstractions
    - multiple abstractions can only be blackboxed at the lowest level (practically)
    - massive monolithic simulation/emulation tools
    - macros on top of macros on top of web of Perl scripts
    -->

    <!--<ul class="small">
      <li class="fragment">Most design is done at the RTL abstraction in Verilog/VHDL</li>
      <li class="fragment">Limitations of these languages lead to a tower of macros on top of macros on top of a web of Perl</li>
      <li class="fragment">Simulation / synthesis semantics mismatch</li>
      <li class="fragment">Compositional semantics of mixing multiple abstractions isn't defined. Everything is lowered to RTL</li>
      <li class="fragment">Simulation / emulation tools are massive monolithic blobs</li>
    </ul>

    An adder is also a design semantic, we could have erased that and let synthesis recover it. but we don't. can we apply this elsewhere?-->
    </div>
  </section>

  <!--
    We're not going to mention the impact of the old / new paradigm on team organization (an industry concern that people here won't care about), or on beauty/ergonomics (too hard to explain in words).
    Also not going to talk about specification synthesis as part of the new paradigm (which includes machine readable specification). This is something we aren't experts on.
  -->

  <!--<section>
    <h2>People and Organization</h2>

    <table class="old_paradigm_table">
      <thead>
      <tr>
        <th></th>
        <th></th>
        <th colspan="5">Teams within an SoC Design Organization</th>
      </tr>
      <tr style="text-align: center;">
        <th></th>
        <th></th>
        <th>Spec / Arch</th>
        <th>Perf Modeling</th>
        <th>RTL</th>
        <th>DV</th>
        <th>PD</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <th rowspan="3" style="vertical-align: middle;">Design block</th>
        <th>Core</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th>LLC</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <th>NPU</th>
        <td class="bg-red"></td>
        <td class="bg-orange"></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
      </tbody>
    </table>

    <ul>
      <li class="fragment">Highly specialized and large workforce</li>
      <li class="fragment">Teams are separated by function rather than design block</li>
      <li class="fragment">Duplicated work between specification, modeling, and RTL</li>
      <li class="fragment">Little interaction between teams</li>
      <li class="fragment">Complex tools and abstractions make transition between functions difficult</li>
    </ul>
  </section>-->

  <!--<section>
    <h2>Specification</h2>
    <div class="center fragment">
      <img class="image" src="./figs/dynamic/latte24/specification.svg" />
      <p><em>Insert picture of random excel spreadsheets, AXI spec documents, DDR state machines</em></p>
    </div>

    <ul>
      <li class="fragment">English, Excel, and drawing specs are the norm</li>
      <li class="fragment">Simulators, models, and verification collateral are handcrafted rather than generated</li>
      <li class="fragment">Translation errors due to undefined behaviors and misinterpretation are common</li>
    </ul>
  </section>-->

  <!--<section>
    <h2>Beauty / Elegance</h2>

    <ul>
      <li>Compare / contrast SystemC HLS vs Halide or EXO as an example</li>
      <li>How else can we demonstrate the lack of beauty?</li>
    </ul>
  </section>-->
</section>

<section class="center">
  <h2>Current vs Next Paradigm</h2>

  <div class="container fragment" style="grid-template-columns: 1fr 1fr; column-gap: 2rem;">
    <div>
      <img style="object-fit: contain; height: 220px;" class="image no-margin" src="/assets/current-paradigm-DzqXsLNK.svg" />
    </div>
    <div>
      <img style="object-fit: contain; height: 220px;" class="image no-margin" src="/assets/new-paradigm-HAG3sSfS.svg" />
    </div>
  </div>

  <p class="center fragment">How do we move towards the next paradigm?</p>

  <ol class="smallish">
    <li class="fragment"><strong>Iteration cycle</strong>: build incremental and fast evaluation tools and languages</li>
    <li class="fragment"><strong>Increase design productivity</strong>: build languages to make RTL design easier</li>
    <li class="fragment"><strong>Capture design semantics</strong>: build an IR that can be enriched with circuit semantics</li>
  </ol>
</section>

<section>
  <section class="center">
    <h2>Our Attempt to Build the Next Paradigm of Hardware Design</h2>

    <ul>
      <li class="fragment">The RTL first methodology (“just go write RTL”)</li>
      <li class="fragment">Building languages and tools for higher design productivity</li>
      <li class="fragment">Building simulators for high fidelity performance evaluation</li>
    </ul>
  </section>

  <section>
    <h2>Typical Hardware Design Cycle</h2>
    <div class="container" style="grid-template-columns: 1.0fr 1.4fr;">
      <div class="fragment">
        <img src="/assets/typical_hw_design-BbbMvDkQ.svg" />
      </div>
      <div>
        <ul>
          <li class="fragment">Iterate over a design point in different abstractions</li>
          <li class="fragment">Use feedback from lower abstractions to guide decisions at higher levels</li>
          <li class="fragment">You are likely to run <strong>a lot of simulations</strong> to get functionality and performance correct</li>
        </ul>
      </div>
    </div>
  </section>

  <section>
    <h2>Limitations of Performance Modeling</h2>
    <div class="center">
      <img class="fragment image no-margin" width="60%" src="/assets/modeling-errors-D4oQeTId.png" />
      <figcaption class="small fragment">Performance models can have large errors with respect to the silicon they are modeling<span class="reference">[1]</span></figcaption>
    </div>

    <ul style="margin-top: 1rem;">
      <li class="fragment">Can we avoid modeling error altogether?</li>
      <li class="fragment">Can we avoid the redundant work of implementing both a performance model and RTL to match it?</li>
    </ul>

    <div class="footnote fragment">
    [1] Akram, Ayaz, and Lina Sawalha. "x86 computer architecture simulators: A comparative study." ICCD 2016.
    </div>
  </section>

  <section>
    <h2>RTL First Design Methodology</h2>

    <div class="container" style="grid-template-columns: 1.0fr 1.6fr;">
      <div class="fragment">
        <img src="/assets/rtl_first_design-CmdunxoM.svg" />
      </div>
      <div>
        <p class="fragment center">We resort to performance models because <strong>writing and evaluating RTL is hard</strong></p>
        <ol>
          <li class="fragment">Make writing RTL so easy that we can <em>do away with performance models</em></li>
          <li class="fragment">Model large and realistic SoCs</li>
          <li class="fragment">Evaluate RTL designs on long and realistic workloads</li>
        </ol>
      </div>
    </div>

    <ol style="margin-top: 1rem;">
      <li class="fragment">Create a high productivity RTL design language and IR: <strong class="green">Chisel &amp; FIRRTL</strong></li>
      <li class="fragment">Create a SoC design framework: <strong class="green">Chipyard</strong></li>
      <li class="fragment">Create a fast RTL simulator: <strong class="green">FireSim</strong></li>
    </ol>
  </section>

  <section>
    <h2>Chisel</h2>
    <div class="center">
      <img class="image" src="/assets/chisel_logo-BRDlx2EG.svg" />
    </div>

    <ul>
      <li class="fragment">Hardware design language (HDL) embedded in Scala</li>
      <li class="fragment">Metaprogramming on top of the RTL abstraction
        <ul>
          <li class="fragment">Scala's OOP and FP constructs enable high expressiveness compared to SystemVerilog</li>
          <li class="fragment">Makes writing RTL more productive</li>
        </ul>
      </li>
    </ul>
  </section>

  <section>
    <h2>Summing a Vector in SystemVerilog</h2>
    <p class="center fragment">Sum a vector with $M$, $N$-bit inputs</p>

    <pre class="fragment" data-id="code-animation"><code class="verilog" data-trim data-line-numbers="1-6|8-18">
    module MyModule
      #(parameter N, M)
      (
        input  [N-1:0] a [0:M-1],
        output [N-1:0] sum
      );

      reg [N-1:0] tmp [0:M];

      tmp[0] = a[0];
      sum = tmp[M];

      genvar i;
      generate
        for (i = 1; i &lt; M; i = i + 1) begin
          tmp[i] = tmp[i-1] + a[i];
        end
      endgenerate
    endmodule
    </code></pre>
  </section>

  <section data-auto-animate>
    <h2>Summing a Vector in Chisel</h2>

    <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="1-5|6">
    class MyModule(N: Int, M: Int) extends Module {
      val io = IO(new Bundle {
        val a = Vec(M, Input(UInt(N.W)))
        val sum  = Output(UInt(N.W))
      })
      io.sum := io.a.reduce(_ + _)
    }
    </code></pre>

    <p class="fragment center">Leverage Scala's collection operators to make working with sequences easy</p>
  </section>

  <section>
    <h2>Benefits of Chisel</h2>
    <ul>
      <li class="fragment">Less verbosity vs SystemVerilog</li>
      <li class="fragment">Easier to compose modules programmatically</li>
      <li class="fragment">eDSL: leverage the constructs and tooling of the host language
        <ul class="fragment">
          <li>Package manager / repositories</li>
          <li>Build systems</li>
          <li>IDE</li>
        </ul>
      </li>
    </ul>
  </section>

  <section>
    <h2>FIRRTL</h2>
    <div class="center">
      <img width="30%" class="image no-margin" src="/assets/firrtl_logo-SiGcuwmv.svg" />
    </div>

    <ul>
      <li class="fragment">Intermediate representation for an elaborated Chisel circuit</li>
      <li class="fragment">Represents the generated circuit after execution of the Scala generator
        <ul>
          <li>Mostly structural: registers, SRAMs, logic / arithmetic elements</li>
        </ul>
      </li>
      <li class="fragment">First-class dialect supported in the MLIR / CIRCT compiler infrastructure</li>
      <!--<li class="fragment">SSA style in memory representation</li>-->
    </ul>
  </section>

  <section>
    <h2>Summing a Vector as FIRRTL</h2>
    <pre data-id="code-animation"><code class="" data-trim data-line-numbers="1-2|3-5|7-13">
    circuit MyModule :
      module MyModule :
        input clock : Clock
        input reset : UInt&lbrack;1&rbrack;
        output io : { flip a : UInt&lbrack;4&rbrack;[4], sum : UInt&lbrack;4&rbrack;}

        node _io_sum_T = add(io.a[0], io.a[1]) @[MyModule.scala 14:27]
        node _io_sum_T_1 = tail(_io_sum_T, 1) @[MyModule.scala 14:27]
        node _io_sum_T_2 = add(_io_sum_T_1, io.a[2]) @[MyModule.scala 14:27]
        node _io_sum_T_3 = tail(_io_sum_T_2, 1) @[MyModule.scala 14:27]
        node _io_sum_T_4 = add(_io_sum_T_3, io.a[3]) @[MyModule.scala 14:27]
        node _io_sum_T_5 = tail(_io_sum_T_4, 1) @[MyModule.scala 14:27]
        io.sum &lt;== _io_sum_T_5 @[MyModule.scala 14:10]
    </code></pre>

    <ul>
      <li>A FIRRTL circuit is composed of modules with ports, similar to SystemVerilog</li>
      <li>Scala-level constructs are gone in FIRRTL</li>
    </ul>
  </section>

  <section>
    <h2>Cool Things That FIRRTL Enables</h2>
    <ul>
      <li class="fragment">Error checking, general-purpose optimizations
        <ul>
          <li>Combinational loop detection</li>
          <li>Dead code elimination (DCE), common subexpression elimination (CSE), constant propagation</li>
        </ul>
      </li>
      <li class="fragment">Clean and programmatic netlist manipulation
        <ul>
          <li class="fragment">Bitvector width inference</li>
          <li class="fragment">Scan-chain instrumentation for state injection / extraction</li>
          <li class="fragment">Regrouping modules (for hierarchical physical design)</li>
          <li class="fragment">Unrolling a circuit for bounded model checking (BMC)</li>
          <!--<li class="fragment">Automatic coverpoint instrumentation</li>-->
        </ul>
      </li>
    </ul>
    <!--<li class="fragment">Given a single design, you are now able to generate various collateral by applying different compiler passes</li>-->
  </section>

  <!--<section>
    <h3>Cool things that FIRRTL enables</h3>
    <ul>
      <li class="fragment">FAME transformations and FireSim</li>
      <figure>
        <img class="fragment" src="./figs/latte24/li-bdn-transformed.svg" />
        <figcaption class="fragment">Bold lines : Target design<br>Dashed lines : Timing control logic</figcaption>
      </figure>
    </ul>
  </section>-->

  <section>
    <div class="center">
      <img width="40%" class="image no-margin" style="padding: 0.5rem;" src="/assets/chipyard_logo-BOSErldK.svg" />
    </div>

    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
    <div>
      <img src="/assets/soc-arch-CEl2QHU1.svg"/>
    </div>
    <div>
      <ul class="smallish">
        <li class="fragment">Chisel-based SoC design framework</li>
        <li class="fragment">Configurations that cover a wide SoC design space
          <ul>
            <li class="fragment">IP library of RISC-V cores, accelerators, bus components, peripherals, and network-on-chip interconnect</li>
          </ul>
        </li>
        <li class="fragment">A methodology for agile SoC architecture design, exploration, and evaluation</li>
        <li class="fragment">A tapeout-ready chassis for custom RISC-V SoCs</li>
      </ul>
    </div>
  </section>

  <section>
    <h2>Chipyard</h2>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
    <div>
      <img src="/assets/chipyard-big-design-zr12TLjP.svg"/>
    </div>
    <div>
      <ul class="smallish">
        <li>Learn how to build and simulate a complex SoC in a matter of hours!
          <ul>
            <li>Tutorial participants configured, elaborated, and simulated this SoC configuration live</li>
          </ul>
        </li>
        <li class="fragment"><a href="https://fires.im/asplos-2023-tutorial/">Link to previous tutorial recordings</a></li>
    </div>
  </section>

  <!--<section class="center">
    <h2>SoC Architecture</h2>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
      <div>
        <img src="./figs/latte24/soc-arch.svg"/>
      </div>
      <div>
        <ul>
          <li class="fragment">We can configure the tiles, accelerators, memory hierarchy, and the interconnect.</li>
        </ul>
      </div>
    </div>
  </section>-->







  <section class="center">
    <h2>FireSim at 35,000 feet</h2>
    <div class="container" style="grid-template-columns: 1.0fr 1.4fr;">
    <div>
      <ul>
        <img class="fragment" data-fragment-index="0" height=400px; src="/assets/firesim-DWzCiWHs.svg" />
      </ul>
    </div>
    <div>
      <ul>
        <li class="fragment" data-fragment-index="0">FPGA accelerated RTL simulation platform</li>
        <li class="fragment">Perform end-to-end performance evaluation with real, long-running, RISC-V workloads on top of an OS</li>
        <li class="fragment">Useful for discovering bugs that appear trillions of cycles into simulation</li>
      </ul>
    </div>
  </section>

  <section class="center">
    <h2>FireSim Impact</h2>
    <div class="r-stack">
      <div>
        <img class="fragment" style="object-fit: contain;" height=500px; src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAzNSIgaGVpZ2h0PSIxNDI2IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWw6c3BhY2U9InByZXNlcnZlIiBvdmVyZmxvdz0iaGlkZGVuIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNjI3IC0yOTcpIj48Zz48cGF0aCBkPSJNNjM5IDU0MC44MzdDNjM5IDQxMS4xNCA3NDQuMTQgMzA2IDg3My44MzcgMzA2TDM0MTYuMTYgMzA2QzM1NDUuODYgMzA2IDM2NTEgNDExLjE0IDM2NTEgNTQwLjgzN0wzNjUxIDE0ODAuMTZDMzY1MSAxNjA5Ljg2IDM1NDUuODYgMTcxNSAzNDE2LjE2IDE3MTVMODczLjgzNyAxNzE1Qzc0NC4xNCAxNzE1IDYzOSAxNjA5Ljg2IDYzOSAxNDgwLjE2WiIgc3Ryb2tlPSIjMDQyNDMzIiBzdHJva2Utd2lkdGg9IjEzLjc1IiBzdHJva2UtbGluZWNhcD0iYnV0dCIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIgc3Ryb2tlLW1pdGVybGltaXQ9IjgiIHN0cm9rZS1vcGFjaXR5PSIxIiBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtb3BhY2l0eT0iMSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZpbGwtb3BhY2l0eT0iMSIgZm9udC1mYW1pbHk9IkFyaWFsLEFyaWFsX01TRm9udFNlcnZpY2Usc2Fucy1zZXJpZiIgZm9udC1zdHlsZT0iaXRhbGljIiBmb250LXZhcmlhbnQ9Im5vcm1hbCIgZm9udC13ZWlnaHQ9IjQwMCIgZm9udC1zdHJldGNoPSJub3JtYWwiIGZvbnQtc2l6ZT0iMTY1IiB0ZXh0LWFuY2hvcj0ic3RhcnQiIGRpcmVjdGlvbj0ibHRyIiB3cml0aW5nLW1vZGU9ImxyLXRiIiB1bmljb2RlLWJpZGk9Im5vcm1hbCIgdGV4dC1kZWNvcmF0aW9uPSJub25lIiB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDgwMi4wODMgNzA5KSI+RmlyZVNpbTwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmaWxsLW9wYWNpdHk9IjEiIGZvbnQtZmFtaWx5PSJBcmlhbCxBcmlhbF9NU0ZvbnRTZXJ2aWNlLHNhbnMtc2VyaWYiIGZvbnQtc3R5bGU9Iml0YWxpYyIgZm9udC12YXJpYW50PSJub3JtYWwiIGZvbnQtd2VpZ2h0PSI0MDAiIGZvbnQtc3RyZXRjaD0ibm9ybWFsIiBmb250LXNpemU9IjE2NSIgdGV4dC1hbmNob3I9InN0YXJ0IiBkaXJlY3Rpb249Imx0ciIgd3JpdGluZy1tb2RlPSJsci10YiIgdW5pY29kZS1iaWRpPSJub3JtYWwiIHRleHQtZGVjb3JhdGlvbj0ibm9uZSIgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAxNDE2LjI1IDcwOSkiPmhhcyBiZWVuIHVzZWQqIGluIHB1Ymxpc2hlZCA8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZmlsbC1vcGFjaXR5PSIxIiBmb250LWZhbWlseT0iQXJpYWwsQXJpYWxfTVNGb250U2VydmljZSxzYW5zLXNlcmlmIiBmb250LXN0eWxlPSJpdGFsaWMiIGZvbnQtdmFyaWFudD0ibm9ybWFsIiBmb250LXdlaWdodD0iNDAwIiBmb250LXN0cmV0Y2g9Im5vcm1hbCIgZm9udC1zaXplPSIxNjUiIHRleHQtYW5jaG9yPSJzdGFydCIgZGlyZWN0aW9uPSJsdHIiIHdyaXRpbmctbW9kZT0ibHItdGIiIHVuaWNvZGUtYmlkaT0ibm9ybWFsIiB0ZXh0LWRlY29yYXRpb249Im5vbmUiIHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMTA5NS40MiA5MDcpIj53b3JrIGZyb20gYXV0aG9ycyBhdCBvdmVyIDIwIDwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmaWxsLW9wYWNpdHk9IjEiIGZvbnQtZmFtaWx5PSJBcmlhbCxBcmlhbF9NU0ZvbnRTZXJ2aWNlLHNhbnMtc2VyaWYiIGZvbnQtc3R5bGU9Iml0YWxpYyIgZm9udC12YXJpYW50PSJub3JtYWwiIGZvbnQtd2VpZ2h0PSI0MDAiIGZvbnQtc3RyZXRjaD0ibm9ybWFsIiBmb250LXNpemU9IjE2NSIgdGV4dC1hbmNob3I9InN0YXJ0IiBkaXJlY3Rpb249Imx0ciIgd3JpdGluZy1tb2RlPSJsci10YiIgdW5pY29kZS1iaWRpPSJub3JtYWwiIHRleHQtZGVjb3JhdGlvbj0ibm9uZSIgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSA4NjYuMjUgMTEwNSkiPmFjYWRlbWljIGFuZCBpbmR1c3RyaWFsIGluc3RpdHV0aW9uczwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmaWxsLW9wYWNpdHk9IjEiIGZvbnQtZmFtaWx5PSJBcmlhbCxBcmlhbF9NU0ZvbnRTZXJ2aWNlLHNhbnMtc2VyaWYiIGZvbnQtc3R5bGU9Iml0YWxpYyIgZm9udC12YXJpYW50PSJub3JtYWwiIGZvbnQtd2VpZ2h0PSI0MDAiIGZvbnQtc3RyZXRjaD0ibm9ybWFsIiBmb250LXNpemU9IjExMCIgdGV4dC1hbmNob3I9InN0YXJ0IiBkaXJlY3Rpb249Imx0ciIgd3JpdGluZy1tb2RlPSJsci10YiIgdW5pY29kZS1iaWRpPSJub3JtYWwiIHRleHQtZGVjb3JhdGlvbj0ibm9uZSIgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAxNDQ3LjQ2IDE0NDgpIj4qPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZpbGwtb3BhY2l0eT0iMSIgZm9udC1mYW1pbHk9IkFyaWFsLEFyaWFsX01TRm9udFNlcnZpY2Usc2Fucy1zZXJpZiIgZm9udC1zdHlsZT0iaXRhbGljIiBmb250LXZhcmlhbnQ9Im5vcm1hbCIgZm9udC13ZWlnaHQ9IjQwMCIgZm9udC1zdHJldGNoPSJub3JtYWwiIGZvbnQtc2l6ZT0iMTEwIiB0ZXh0LWFuY2hvcj0ic3RhcnQiIGRpcmVjdGlvbj0ibHRyIiB3cml0aW5nLW1vZGU9ImxyLXRiIiB1bmljb2RlLWJpZGk9Im5vcm1hbCIgdGV4dC1kZWNvcmF0aW9uPSJub25lIiB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDE0OTAuNDMgMTQ0OCkiPmFjdHVhbGx5IHVzZWQ8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZmlsbC1vcGFjaXR5PSIxIiBmb250LWZhbWlseT0iQXJpYWwsQXJpYWxfTVNGb250U2VydmljZSxzYW5zLXNlcmlmIiBmb250LXN0eWxlPSJpdGFsaWMiIGZvbnQtdmFyaWFudD0ibm9ybWFsIiBmb250LXdlaWdodD0iNDAwIiBmb250LXN0cmV0Y2g9Im5vcm1hbCIgZm9udC1zaXplPSIxMTAiIHRleHQtYW5jaG9yPSJzdGFydCIgZGlyZWN0aW9uPSJsdHIiIHdyaXRpbmctbW9kZT0ibHItdGIiIHVuaWNvZGUtYmlkaT0ibm9ybWFsIiB0ZXh0LWRlY29yYXRpb249Im5vbmUiIHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMjEzMy4yNCAxNDQ4KSI+LCBub3Qgb25seSBjaXRlZDwvdGV4dD48L2c+PC9nPjwvc3ZnPg==" />
      </div>
      <div>
      <ul class="smallish">
        <li>ISCA ‘18: Maas et. al.  HW-GC Accelerator (Berkeley)</li>
        <li>MICRO ‘18: Zhang et. al. “Composable Building Blocks to Open up Processor Design” (MIT)</li>
        <li>RTAS ‘20: Farshchi et. al. BRU (Kansas)</li>
        <li>EuroSys ‘20: Lee et. al. Keystone (Berkeley)</li>
        <li>OSDI ‘21: Ibanez et. al. nanoPU (Stanford)</li>
        <li>USENIX Security ‘21: Saileshwar et. al. MIRAGE (Georgia Tech)</li>
        <li>CCS ‘21: Ding et. al. “Hardware Support to Improve Fuzzing Performance and Precision” (Georgia Tech)</li>
        <li>MICRO ’21: Karandikar et. al. “A Hardware Accelerator for Protocol Buffers” (Berkeley/Google)</li>
        <li>MICRO ‘21: Gottschall et. al. TIP (NTNU)</li>
        <li>Over 20 additional user papers on the FireSim website:</li>
        <li><a href="https://fires.im/publications/#userpapers">https://fires.im/publications/#userpapers</a></li>
      </ul>
      </div>
    </div>
  </section>

  <section class="center">
    <h2>Overview of the Berkeley Infrastructure</h2>
    <div class="container" style="grid-template-columns: 1.0fr 1.4fr; column-gap: 2rem;">
      <div class="center">
        <img class="image" src="/assets/tool-stack-hudsUx8J.svg" />
      </div>
      <div>
        <dl>
          <div class="fragment">
            <dt>Chisel &amp; FIRRTL</dt>
            <dd class="">Productive design language and IR</dd>
          </div>
          <div class="fragment">
            <dt>Chipyard</dt>
            <dd>Composable SoC design framework</dd>
          </div>
          <div class="fragment">
            <dt>FireSim</dt>
            <dd>High throughput RTL simulation</dd>
          </div>
        </dl>
      </div>
    </div>
  </section>
</section>


<section>
  <section class="center">
    <h2>The Current State of Mixed Abstraction SoC Integration</h2>
    <p class="center fragment"><strong>Demo:</strong> Integrating IP from another design language to perform full system SoC-level evaluation</p>
  </section>

  <section class="center">
    <h2>Key Takeaways</h2>
    <ul>
      <li class="fragment">External IP integration works, but not seamless as it could be
        <ul>
          <li class="fragment">Lots of ad-hoc gluecode</li>
          <li class="fragment">Redundant parameter definitions</li>
          <li class="fragment">Restricted to Verilog blackboxing and on predefined integration interfaces</li>
        </ul>
      </li>
      <li class="fragment">These takeaways are applicable to all SoC design frameworks out there (not just Chipyard)</li>
    </ul>
  </section>

  <section>
    <h3>Step 1: Generate RTL From Your HDL (e.g. Calyx)</h3>
    <pre data-id="code-animation"><code class="verilog" data-trim>
    component CalyxSumBlackBox(in: 4) -> (out: 4) {
      cells { ... }
      wires { ... }
      control { ... }
    }
    </code></pre>
    <p class="center fragment">
      Receive a 4-bit input, add it three times to itself across multiple cycles, then output the result
    </p>
  </section>

  <section>
    <h3>Step 2: Create a Verilog BlackBox in Chisel</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.5fr;">
      <div>
        <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers>
        class CalyxSumIO(nBits: Int) extends Bundle {
          val clk   = Input(Clock())
          val reset = Input(Bool())

          val in    = Input(UInt(nBits.W))
          val go    = Input(Bool())

          val out   = Output(UInt(nBits.W))
          val done  = Output(Bool())
        }

        class CalyxSumBlackBox(nBits: Int)
            extends BlackBox
            with HasBlackBoxResource {
          val io = IO(new CalyxSumIO(nBits))
          addResource("/vsrc/aggregator.sv")
        }
        </code></pre>
      </div>
      <div>
        <img class="fragment" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOTE2IiBoZWlnaHQ9IjYxNSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgb3ZlcmZsb3c9ImhpZGRlbiI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTE0MDcgLTk4MCkiPjxnPjxyZWN0IHg9IjE0MTUuNSIgeT0iOTkzLjUiIHdpZHRoPSI4OTkiIGhlaWdodD0iNTk5IiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iNC41ODMzMyIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiIHN0cm9rZS1saW5lam9pbj0ibWl0ZXIiIHN0cm9rZS1taXRlcmxpbWl0PSI4IiBzdHJva2Utb3BhY2l0eT0iMSIgZmlsbD0iIzhFRDk3MyIgZmlsbC1vcGFjaXR5PSIxIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZmlsbC1vcGFjaXR5PSIxIiBmb250LWZhbWlseT0iQXJpYWwsQXJpYWxfTVNGb250U2VydmljZSxzYW5zLXNlcmlmIiBmb250LXN0eWxlPSJub3JtYWwiIGZvbnQtdmFyaWFudD0ibm9ybWFsIiBmb250LXdlaWdodD0iNDAwIiBmb250LXN0cmV0Y2g9Im5vcm1hbCIgZm9udC1zaXplPSI5MiIgdGV4dC1hbmNob3I9InN0YXJ0IiBkaXJlY3Rpb249Imx0ciIgd3JpdGluZy1tb2RlPSJsci10YiIgdW5pY29kZS1iaWRpPSJub3JtYWwiIHRleHQtZGVjb3JhdGlvbj0ibm9uZSIgdHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAxNDY0LjE4IDEwOTkpIj5DYWx5eFN1bUJsYWNrQm94PC90ZXh0PjxyZWN0IHg9IjE0OTYuNSIgeT0iMTEzNi41IiB3aWR0aD0iNzM4IiBoZWlnaHQ9IjQyMCIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQuNTgzMzMiIHN0cm9rZS1saW5lY2FwPSJidXR0IiBzdHJva2UtbGluZWpvaW49Im1pdGVyIiBzdHJva2UtbWl0ZXJsaW1pdD0iOCIgc3Ryb2tlLW9wYWNpdHk9IjEiIGZpbGw9IiNFMUVGRDgiIGZpbGwtb3BhY2l0eT0iMSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZpbGwtb3BhY2l0eT0iMSIgZm9udC1mYW1pbHk9IkFyaWFsLEFyaWFsX01TRm9udFNlcnZpY2Usc2Fucy1zZXJpZiIgZm9udC1zdHlsZT0ibm9ybWFsIiBmb250LXZhcmlhbnQ9Im5vcm1hbCIgZm9udC13ZWlnaHQ9IjQwMCIgZm9udC1zdHJldGNoPSJub3JtYWwiIGZvbnQtc2l6ZT0iOTIiIHRleHQtYW5jaG9yPSJzdGFydCIgZGlyZWN0aW9uPSJsdHIiIHdyaXRpbmctbW9kZT0ibHItdGIiIHVuaWNvZGUtYmlkaT0ibm9ybWFsIiB0ZXh0LWRlY29yYXRpb249Im5vbmUiIHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMTU3MS41NiAxMzgwKSI+U3lzdGVtVmVyaWxvPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZpbGwtb3BhY2l0eT0iMSIgZm9udC1mYW1pbHk9IkFyaWFsLEFyaWFsX01TRm9udFNlcnZpY2Usc2Fucy1zZXJpZiIgZm9udC1zdHlsZT0ibm9ybWFsIiBmb250LXZhcmlhbnQ9Im5vcm1hbCIgZm9udC13ZWlnaHQ9IjQwMCIgZm9udC1zdHJldGNoPSJub3JtYWwiIGZvbnQtc2l6ZT0iOTIiIHRleHQtYW5jaG9yPSJzdGFydCIgZGlyZWN0aW9uPSJsdHIiIHdyaXRpbmctbW9kZT0ibHItdGIiIHVuaWNvZGUtYmlkaT0ibm9ybWFsIiB0ZXh0LWRlY29yYXRpb249Im5vbmUiIHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMjEwNi43NSAxMzgwKSI+ZzwvdGV4dD48L2c+PC9nPjwvc3ZnPg=="/>
      </div>
    <div>
  </section>

  <section data-auto-animate>
    <h3>Step 3: Generate a MMIO Wrapper in Chipyard</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.5fr;">
      <div class="tiny">
        <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="1-35|37-73">
        case class CalyxSumParams(
          address: BigInt = 0x5000,
          qDepth: Int = 4,
          nBits: Int = 4,
          nSum: Int = 3)

        case object CalyxSumKey extends Field[Option[CalyxSumParams]](None)

        class CalyxSumMMIOWrapper(
          params: CalyxSumParams, beatBytes: Int
        )(
          implicit p: Parameters
        ) extends ClockSinkDomain(ClockSinkParameters())(p) {
          val device = new SimpleDevice("calyx-sum", Seq("ucbbar,calyx-sum"))
          val node = TLRegisterNode(Seq(AddressSet(params.address, 4096-1)),
                                        device,
                                        "reg/control",
                                        beatBytes=beatBytes)

          val nBits = params.nBits
          val nSum  = params.nSum

          override lazy val module = new MMIOWrapperImpl

          class MMIOWrapperImpl extends Impl with HasCalyxSumTopIO {
            val io = IO(new CalyxSumTopIO)

            withClockAndReset(clock, reset) {
              val bb    = Module(new CalyxSumBlackBox(nBits))
              val in_q  = Module(new Queue(UInt(nBits.W), params.qDepth))
              val out_q = Module(new Queue(UInt(nBits.W), params.qDepth))

              val go = RegInit(false.B)
              val cnt = RegInit(0.U(8.W))

              switch (go) {
                is (false.B) {
                  when (in_q.io.count > 0.U && out_q.io.enq.ready) {
                    go := true.B
                    cnt := 0.U
                  }
                }

                is (true.B) {
                  when (bb.io.done) {
                    go := false.B
                  }
                }
              }

              bb.io.clk   := clock
              bb.io.reset := reset.asBool
              bb.io.go    := go
              bb.io.in    := in_q.io.deq.bits
              in_q.io.deq.ready := bb.io.done

              out_q.io.enq.bits  := bb.io.out
              out_q.io.enq.valid := bb.io.done
              io.done := bb.io.done

              when (bb.io.done) {
                assert(out_q.io.enq.ready)
              }

              node.regmap(
                0x00 -> Seq(RegField.r(1,     in_q.io.enq.ready)),
                0x04 -> Seq(RegField.w(nBits, in_q.io.enq)),
                0x08 -> Seq(RegField.r(1,     out_q.io.deq.valid)),
                0x0C -> Seq(RegField.r(nBits, out_q.io.deq))
              )
            }
          }
        }
        </code></pre>
      </div>
      <div>
        <img class="fragment" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTEzMiIgaGVpZ2h0PSI4MzAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbDpzcGFjZT0icHJlc2VydmUiIG92ZXJmbG93PSJoaWRkZW4iPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMzAxIC04MjApIj48Zz48cmVjdCB4PSIxMzIxLjUiIHk9IjgzMi41IiB3aWR0aD0iMTA5OCIgaGVpZ2h0PSI4MTEiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0LjU4MzMzIiBzdHJva2UtbGluZWNhcD0iYnV0dCIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIgc3Ryb2tlLW1pdGVybGltaXQ9IjgiIHN0cm9rZS1vcGFjaXR5PSIxIiBmaWxsPSIjNEU5NUQ5IiBmaWxsLW9wYWNpdHk9IjEiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmaWxsLW9wYWNpdHk9IjEiIGZvbnQtZmFtaWx5PSJBcmlhbCxBcmlhbF9NU0ZvbnRTZXJ2aWNlLHNhbnMtc2VyaWYiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZm9udC12YXJpYW50PSJub3JtYWwiIGZvbnQtd2VpZ2h0PSI0MDAiIGZvbnQtc3RyZXRjaD0ibm9ybWFsIiBmb250LXNpemU9IjkyIiB0ZXh0LWFuY2hvcj0ic3RhcnQiIGRpcmVjdGlvbj0ibHRyIiB3cml0aW5nLW1vZGU9ImxyLXRiIiB1bmljb2RlLWJpZGk9Im5vcm1hbCIgdGV4dC1kZWNvcmF0aW9uPSJub25lIiB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDEzNjEuMzUgOTM4KSI+Q2FseXhTdW1NTUlPV3JhcHBlcjwvdGV4dD48cmVjdCB4PSIxNDIwLjUiIHk9Ijk5My41IiB3aWR0aD0iODk5IiBoZWlnaHQ9IjU5OSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjQuNTgzMzMiIHN0cm9rZS1saW5lY2FwPSJidXR0IiBzdHJva2UtbGluZWpvaW49Im1pdGVyIiBzdHJva2UtbWl0ZXJsaW1pdD0iOCIgc3Ryb2tlLW9wYWNpdHk9IjEiIGZpbGw9IiM4RUQ5NzMiIGZpbGwtb3BhY2l0eT0iMSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZpbGwtb3BhY2l0eT0iMSIgZm9udC1mYW1pbHk9IkFyaWFsLEFyaWFsX01TRm9udFNlcnZpY2Usc2Fucy1zZXJpZiIgZm9udC1zdHlsZT0ibm9ybWFsIiBmb250LXZhcmlhbnQ9Im5vcm1hbCIgZm9udC13ZWlnaHQ9IjQwMCIgZm9udC1zdHJldGNoPSJub3JtYWwiIGZvbnQtc2l6ZT0iOTIiIHRleHQtYW5jaG9yPSJzdGFydCIgZGlyZWN0aW9uPSJsdHIiIHdyaXRpbmctbW9kZT0ibHItdGIiIHVuaWNvZGUtYmlkaT0ibm9ybWFsIiB0ZXh0LWRlY29yYXRpb249Im5vbmUiIHRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMTQ2OS4wOSAxMDk5KSI+Q2FseXhTdW1CbGFja0JveDwvdGV4dD48cmVjdCB4PSIxNTAwLjUiIHk9IjExMzYuNSIgd2lkdGg9IjczOSIgaGVpZ2h0PSI0MjAiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI0LjU4MzMzIiBzdHJva2UtbGluZWNhcD0iYnV0dCIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciIgc3Ryb2tlLW1pdGVybGltaXQ9IjgiIHN0cm9rZS1vcGFjaXR5PSIxIiBmaWxsPSIjRTFFRkQ4IiBmaWxsLW9wYWNpdHk9IjEiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmaWxsLW9wYWNpdHk9IjEiIGZvbnQtZmFtaWx5PSJBcmlhbCxBcmlhbF9NU0ZvbnRTZXJ2aWNlLHNhbnMtc2VyaWYiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZm9udC12YXJpYW50PSJub3JtYWwiIGZvbnQtd2VpZ2h0PSI0MDAiIGZvbnQtc3RyZXRjaD0ibm9ybWFsIiBmb250LXNpemU9IjkyIiB0ZXh0LWFuY2hvcj0ic3RhcnQiIGRpcmVjdGlvbj0ibHRyIiB3cml0aW5nLW1vZGU9ImxyLXRiIiB1bmljb2RlLWJpZGk9Im5vcm1hbCIgdGV4dC1kZWNvcmF0aW9uPSJub25lIiB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDE1NzYuNDcgMTM4MCkiPlN5c3RlbVZlcmlsbzwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmaWxsLW9wYWNpdHk9IjEiIGZvbnQtZmFtaWx5PSJBcmlhbCxBcmlhbF9NU0ZvbnRTZXJ2aWNlLHNhbnMtc2VyaWYiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZm9udC12YXJpYW50PSJub3JtYWwiIGZvbnQtd2VpZ2h0PSI0MDAiIGZvbnQtc3RyZXRjaD0ibm9ybWFsIiBmb250LXNpemU9IjkyIiB0ZXh0LWFuY2hvcj0ic3RhcnQiIGRpcmVjdGlvbj0ibHRyIiB3cml0aW5nLW1vZGU9ImxyLXRiIiB1bmljb2RlLWJpZGk9Im5vcm1hbCIgdGV4dC1kZWNvcmF0aW9uPSJub25lIiB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDIxMTEuNjYgMTM4MCkiPmc8L3RleHQ+PC9nPjwvZz48L3N2Zz4="/>
      </div>
    </div>
  </section>

  <section data-auto-animate>
    <h3>Step 4: Add MMIO ports to the Peripheral Bus</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1fr;">
      <div class="tiny">
        <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="">
        trait CanHaveMMIOCalyxSum { this: BaseSubsystem =>
          private val pbus = locateTLBusWrapper(PBUS)

          val calyx_sum_done = p(CalyxSumKey) match {
            case Some(params) => {
              val cs = LazyModule(new CalyxSumMMIOWrapper(params, pbus.beatBytes)(p))
              cs.clockNode := pbus.fixedClockNode
              pbus.coupleTo("calyx_sum_mmio_wrapper") {
                cs.node := TLFragmenter(pbus.beatBytes, pbus.blockBytes) := _
              }

              // Add port to DigitalTop (just for fun)
              val calyx_sum_done = InModuleBody {
                val done = IO(Output(Bool())).suggestName("calyx_sum_done")
                done := cs.module.io.done
                done
              }
              Some(calyx_sum_done)
            }
            case None => None
          }
        }

        class DigitalTop(implicit p: Parameters) extends ChipyardSystem
          // Enables optionally adding a Calyx generated module as a MMIO device
          with chipyard.example.CanHaveMMIOCalyxSum
        {
          override lazy val module = new DigitalTopModule(this)
        }
        </code></pre>
      </div>
      <div>
        <img class="fragment" src="/assets/demo-create-port-DAA7lM42.svg" />
      </div>
    </div>
  </section>

  <section data-auto-animate>
    <h3>Step 5: Configure your SoC to Use the MMIO Module</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.5fr;">
      <div>
        <font size="5">
        <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers>
        class WithCalyxSum extends Config((site, here, up) => {
          case CalyxSumKey => Some(CalyxSumParams())
        })

        class CalyxSumRocketConfig extends Config(
          new chipyard.example.WithCalyxSum ++
          new freechips.rocketchip.subsystem.WithNBigCores(1) ++
          new chipyard.config.AbstractConfig)
        </code></pre>
        </font>
      </div>
      <div>
        <img class="fragment" src="/assets/demo-overall-soc-CplCIjP5.svg" />
      </div>
    </div>
    <p class="center fragment">At this point, the SoC level configuration is finished</p>
  </section>

  <section data-auto-animate>
    <h3>Step 6: Write Software to Talk to the MMIO Device</h3>
    <font size="4">
    <pre data-id="code-animation"><code class="cpp" data-trim data-line-numbers="1-30|34-51">
    #define CALYX_SUM_BASE 0x5000
    #define CALYX_SUM_ENQ_RDY  (CALYX_SUM_BASE + 0)
    #define CALYX_SUM_ENQ_BITS (CALYX_SUM_BASE + 4)
    #define CALYX_SUM_DEQ_VAL  (CALYX_SUM_BASE + 8)
    #define CALYX_SUM_DEQ_BITS (CALYX_SUM_BASE + 12)


    static inline int calyx_sum_enq_ready() {
      int rdy = reg_read32(CALYX_SUM_ENQ_RDY);
      printf("calyx_sum_enq_ready: %d\n", rdy);
      return (rdy != 0);
    }

    static inline void calyx_sum_send_input(int val) {
      while (!calyx_sum_enq_ready());
      printf("sending input: %d\n", val);
      reg_write32(CALYX_SUM_ENQ_BITS, val & 0xf);
      printf("sending input done\n");
    }

    static inline int calyx_sum_deq_valid() {
      int val = reg_read32(CALYX_SUM_DEQ_VAL);
      printf("calyx_sum_deq_val: %d\n", val);
      return (val != 0);
    }

    static inline int calyx_sum_get_output() {
      while (!calyx_sum_deq_valid());
      return reg_read32(CALYX_SUM_DEQ_BITS);
    }

    #define TEST_SIZE 3

    int main() {

      int test_inputs[TEST_SIZE] = {1, 2, 3};

      for (int i = 0; i &lt; TEST_SIZE; i++) {
        calyx_sum_send_input(test_inputs[i]);

        int out = calyx_sum_get_output();
        int expect = test_inputs[i] * 3;

        if (out != expect) {
          printf("expect %d got %d\n", expect, out);
          return 1;
        }
      }
      printf("[*] Test success!\n");
      return 0;
    }
    </code></pre>
    </font>
  </section>

  <section data-auto-animate>
    <h3>Step 7: Run SoC-level Integration Tests</h3>
    <pre data-id="code-animation"><code class="bash" data-trim data-line-numbers="5">
    cd chipyard/tests
    make
    cd -
    cd chipyard/sims/verilator
    make -j$(nproc) run-binary CONFIG=CalyxSumRocketConfig BINARY=../../tests/calyx-sum.riscv
    </code></pre>
  </section>

  <section class="center">
    <h3>Step 7: Run SoC-level Integration Tests</h3>
    <img height=500px; src="/assets/calyx-uartlog-CNvwKSa9.png" />
  </section>

  <section class="center">
    <h2>Resources</h2>
    <div class="container" style="grid-template-columns: 1.0fr 1.0fr;">
      <div>
        <img class="image" style="object-fit: contain; height: 300px;" src="/assets/chipyard-docs-qO5ZNr9o.svg"/>
      </div>
      <div>
        <img class="image" style="object-fit: contain; height: 300px;" src="/assets/firesim-docs-CbtEjMba.jpg"/>
      </div>
    </div>
    <ul>
      <li><a href="https://chipyard.readthedocs.io/en/stable/">Chipyard docs</a></li>
      <li><a href="https://docs.fires.im/en/stable/">FireSim docs</a></li>
    </ul>
  </section>
</section>

<!-- -------------------------------------------------------------------- -->


<section>
  <section class="center">
    <h2>Are We There Yet?</h2>
    <div class="container" style="grid-template-columns: 1fr 1fr; column-gap: 2rem;">
      <div>
        <img style="object-fit: contain; height: 220px;" class="image no-margin" src="/assets/current-paradigm-DzqXsLNK.svg" />
      </div>
      <div>
        <img style="object-fit: contain; height: 220px;" class="image no-margin" src="/assets/new-paradigm-HAG3sSfS.svg" />
      </div>
    </div>

    <ol style="margin-top: 1rem;">
      <li class="fragment"><strong class="red">Long iteration time</strong>: generator and simulator is rebuilt for any change</li>
      <li class="fragment"><strong class="red">Integration of multiple abstractions</strong>: coarse-grained and un-ergonomic</li>
      <li class="fragment"><strong class="red">Lost semantics</strong>: SystemVerilog is still the lowest common denominator</li>
    </ol>

    <p class="center fragment"><strong>We still have a long way to go</strong></p>
  </section>

  <section>
    <h2>What are the Problems?</h2>

    <ol>
      <li class="fragment"><strong class="red">Long iteration time</strong>
        <ul class="small">
          <li class="fragment">More abstraction layers (Chisel → FIRRTL → Verilog) ⮕ longer elaboration time</li>
          <li class="fragment">No incrementalism ⮕ rebuild everything whenever anything changes</li>
          <li class="fragment">FireSim as simulation workhorse ⮕ bottlenecked by FPGA build times</li>
          <li class="fragment">Evaluation of PPA requires traditional VLSI tools ⮕ can't iterate on PPA</li>
        </ul>
      </li>
      <li class="fragment"><strong class="red">Integration of multiple abstractions</strong>
        <ul class="small">
          <li class="fragment">IP integration is at the RTL level via ad-hoc blackboxing or DPI</li>
          <li class="fragment">No common simulation substrate for mixed abstraction designs</li>
        </ul>
      </li>
      <li class="fragment"><strong class="red">Loss of semantics</strong>
        <ul class="small">
          <li class="fragment">Synthesis tools must still reconstruct circuit structures from RTL</li>
          <li class="fragment">Power/reset/clock/PD semantics aren't fully captured in the frontend</li>
        </ul>
      </li>
    </ol>
  </section>

  <section class="center">
    <h2>Rest of The Talk</h2>
    <div class="container" style="grid-template-columns: 1.0fr 1.4fr;">
      <div>
        <img class="image" src="/assets/tool-stack-hudsUx8J.svg" />
      </div>
      <div>
        <p class="center">Our take on design considerations for the next generation of hardware design languages and tools</p>
      </div>
    </div>
  </section>
</section>

<!-- -------------------------------------------------------------------- -->

<section>
  <section class="center">
    <h2>Language Frontend & IR</h2>
    <div class="container" style="grid-template-columns: 1.2fr 1.0fr;">
      <div>
        <img style="object-fit: contain; height: 220px;" class="image no-margin" src="/assets/new-paradigm-HAG3sSfS.svg"/>
      </div>
      <div>
        <ol class="smallish">
          <li class="fragment"><strong class="green">Fast iteration</strong>: incremental compilation and caching at every layer</li>
          <li class="fragment"><strong class="green">Design productivity</strong>: mixed abstraction frontend by defining elaboration-time interop APIs and semantics</li>
          <li class="fragment"><strong class="green">Semantics preservation</strong>: native mixed abstraction simulations and rich IR primitives</li>
        </ol>
      </div>
    </div>
  </section>

  <section>
    <h2>1. <span class="green">Incremental First</span></h2>
    <ul>
      <li class="fragment">Hours &rarr; minutes to obtain simulation + PPA results</li>
      <li class="fragment">Encourage designers to try out new ideas without fearing latency</li>
      <li class="fragment">Make <strong>direct iteration on the design</strong> <em>(not a model)</em> feasible</li>
      <!--<li class="fragment">Easier to fix backend tool issues (e.g. critical path, DRC)</li>-->
    </ul>
  </section>

  <section data-auto-animate>
    <h2>1. <span class="green">Incremental First</span></h2>
    <ul>
      <li class="fragment" data-fragment-index="0">Faster iterations ⮕ faster convergence on correctness and optimization</li>
      <li class="fragment" data-fragment-index="1">It's quick to sketch out a module, but time consuming to fix every bug
        <ul>
          <li>Software-like <strong>edit-run-debug loop</strong> is key</li>
        </ul>
      </li>
      <!--Most of the times, we write the entire module, and make small bug fixes</li>-->
    </ul>

    <div class="container" style="grid-template-columns: 1.0fr 1.2fr; column-gap: 2rem;">
      <div class="r-stack">
        <div>
          <img class="fragment" height=300px; data-fragment-index="2" src="/assets/incremental-motivation-base-BL24Ytrt.svg" />
        </div>
        <div>
          <img class="fragment" height=300px; data-fragment-index="3" src="/assets/incremental-motivation-delta-CYIDgPIQ.svg" />
        </div>
        <div>
          <img class="fragment" height=300px; data-fragment-index="4" src="/assets/incremental-motivation-missing-Cfg_oFji.svg" />
        </div>
      </div>
      <div>
        <ul>
          <li class="fragment" data-fragment-index="4">A tiny change shouldn't rebuild the full SoC design and simulator</li>
          <li class="fragment">Primary bottlenecks
            <ul class="smallish">
              <li class="fragment"><strong>Early design stage</strong>: fix functionality, add features ⮕ design elaboration + simulator compilation</li>
              <li class="fragment"><strong>Mature design</strong>: fix critical paths, optimize area / power ⮕ VLSI</li>
            </ul>
          </li>
        </ul>
      </div>
    </div>



  </section>

  <section>
    <h2>1. <span class="green">Incremental First</span></h2>
    <div class="container" style="grid-template-columns: 1.0fr 1.0fr;">
      <div class="r-stack">
        <img style="object-fit: contain;" class="image fragment fade-in-then-out" data-fragment-index="0" height=400px; src="/assets/incremental-motivation-base-BL24Ytrt.svg" />
        <img style="object-fit: contain;" class="image fragment fade-in-then-out" data-fragment-index="1" height=400px; src="/assets/incremental-motivation-base-BL24Ytrt.svg" />
        <img style="object-fit: contain;" class="image fragment fade-in-then-out" data-fragment-index="2" height=400px; src="/assets/incremental-motivation-base-BL24Ytrt.svg" />
        <img style="object-fit: contain;" class="image fragment fade-in-then-out" data-fragment-index="3" height=400px; src="/assets/incremental-motivation-delta-CYIDgPIQ.svg" />
        <img style="object-fit: contain;" class="image fragment fade-in-then-out" data-fragment-index="4" height=400px; src="/assets/incremental-motivation-1-yafGK7Qz.svg" />
        <img style="object-fit: contain;" class="image fragment"                  data-fragment-index="5" height=400px; src="/assets/incremental-motivation-2-DIu9nX2U.svg" />
      </div>
      <div>
        <ul>
          <li class="fragment" data-fragment-index="0"><strong class="green">Caching + incrementalism throughout the stack</strong></li>
          <li class="fragment" data-fragment-index="1">Isolate parts of the design affected by a change</li>
          <li class="fragment" data-fragment-index="2">Only run passes on the modified parts</li>
          <ul class="small">
            <li class="fragment" data-fragment-index="3">Changes to the frontend</li>
            <li class="fragment" data-fragment-index="4">Compiler pass propagates the changes</li>
            <li class="fragment" data-fragment-index="5">VLSI tools propagates the changes</li>
          </ul>
          <li class="fragment" data-fragment-index="7">Extend incrementalism to RTL simulation (LiveSim<span class="reference">[1]</span>) and PPA evaluation (LiveSynth<span class="reference">[2]</span>)</li>
        </ul>
      </div>
    </div>

    <div class="footnote fragment">
    [1] Skinner, Haven, Rafael Trapani Possignolo, Sheng-Hong Wang, and Jose Renau. "LiveSim: A fast hot reload simulator for HDLs." ISPASS 2020.
    [2] Possignolo, Rafael Trapani, and Jose Renau. "LiveSynth: Towards an interactive synthesis flow." DAC 2017.<br />
    </div>
  </section>


  <section>
    <h2>2. <span class="green">Mixed Abstraction Design</span></h2>
    <ul>
      <li class="fragment">Enables high design productivity
        <ul>
          <li class="fragment">Pick the abstraction suitable for a design block</li>
          <li class="fragment">Incrementally refine to hit QoR targets: Model &rarr; HLS &rarr; RTL</li>
          <li class="fragment">Mix abstractions at a fine granularity</li>
        </ul>
      </li>
      <li class="fragment">Native mixed-abstraction simulators
        <ul>
          <li>Higher simulation throughput</li>
          <li>Lower simulator build latency</li>
        </ul>
      </li>
      <li class="fragment">Leverage SoC-level configuration/parameterization system
        <ul>
          <li>Pass SoC integration collateral to IP generators</li>
        </ul>
      </li>
      <li class="fragment"><span class="green"><strong>Progress:</strong></span> <a href="https://www.ovpworld.org/technology_systemc">SystemC virtual platforms</a>, <a href="https://github.com/zeroasiccorp/switchboard">switchboard</a>, <a href="https://github.com/cocotb/cocotb">cocotb</a>, <a href="https://docs.fires.im/en/stable/Golden-Gate/Bridges.html">FireSim bridges to CPU or FPGA hosted models</a>
        <ul>
          <li class="fragment">Limited range of abstraction support</li>
          <li class="fragment">Coarse-grained mixing</li>
          <!--<li class="fragment">Makes it difficult to perform incremental refinement in reality</li>-->
          <li class="fragment">Clunky and un-ergonomic APIs</li>
        </ul>
      </li>
    </ul>
  </section>

  <section>
    <h2>2. <span class="green">Mixed Abstraction Design</span></h2>
    <div class="container" style="grid-template-columns: 1.2fr 1.0fr; column-gap: 2rem;">
      <div class="r-stack">
        <img style="object-fit: contain;" class="image fragment fade-in-then-out" data-fragment-index="0" src="/assets/multi-abstraction-base-B_LlFfeV.svg" />
        <img style="object-fit: contain;" class="image fragment fade-in-then-out" data-fragment-index="1" src="/assets/multi-abstraction-rtl-BUVI1Eio.svg" />
        <img style="object-fit: contain;" class="image fragment fade-in-then-out" data-fragment-index="2" src="/assets/multi-abstraction-ctrl-DFreRtvG.svg" />
        <img style="object-fit: contain;" class="image fragment fade-in-then-out" data-fragment-index="3" src="/assets/multi-abstraction-data-DXxMtXcB.svg" />
        <img style="object-fit: contain;" class="image fragment fade-in-then-out" data-fragment-index="4" src="/assets/multi-abstraction-accel-CCpBltb_.svg" />
        <img style="object-fit: contain;" class="image fragment fade-in-then-out" data-fragment-index="5" src="/assets/multi-abstraction-soc-Cf1SBjZ_.svg" />
      </div>
      <div>
        <ul>
          <li class="fragment" data-fragment-index="1"><strong>RTL</strong>: cores and caches</li>
          <li class="fragment" data-fragment-index="2"><strong>Control flow synthesis</strong>: bus components, peripherals</li>
          <li class="fragment" data-fragment-index="3"><strong>Dataflow synthesis</strong>: dataflow accelerators</li>
          <li class="fragment" data-fragment-index="4"><strong>Accelerator design languages</strong>: accelerators</li>
          <li class="fragment" data-fragment-index="5"><strong>SoC</strong>: mosaic of different abstractions</li>
        </ul>
      </div>
    </div>
  </section>

  <section>
    <h2>2. <span class="green">Mixed Abstraction Design</span></h2>
    <div class="center">
        <img style="object-fit: contain; height: 220px;" class="image no-margin" src="/assets/new-paradigm-elab-interop-CTDHD2u7.svg"/>
    </div>

    <ul style="margin-top: 1rem;">
      <li class="fragment">Clean elaboration-time interop
        <ul>
          <li>API-level mechanism for calling between abstractions</li>
          <li>Define semantics with respect to the legality of cross-abstraction interactions</li>
        </ul>
      </li>
      <li class="fragment">Different abstractions sit on top of the elaboration-time interop shim</li>
    </ul>
  </section>

  <section data-auto-animate>
    <h2>2. <span class="green">Mixed Abstraction Design</span></h2>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
      <div>
        <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers>
        object ElaborationInterop {
          def compose(rtl : RTL, hls: HLS): Option[Edge]
          def compose(rtl : RTL, als: ALS): Option[Edge]
        }
        </code></pre>
        <img style="object-fit: contain; height: 220px;" class="fragment image no-margin" src="/assets/elab-interop-VgV80Y9C.svg" />
      </div>
      <div>
        <ul>
          <li class="fragment"><strong>Elaboration interop</strong>: how to combine multiple abstractions</li>
          <li class="fragment"><strong>Practical consideration</strong>
            <ul>
              <li>FFI<span class="reference">[1]</span> for calling into external generators</li>
            </ul>
          </li>
          <li class="fragment"><strong>Semantics</strong>
            <ul>
              <li>Which connections are legal</li>
              <li>APIs that define the interaction mechanism between abstractions</li>
            </ul>
          </li>
        </ul>
      </div>
    </div>

    <div class="footnote fragment">
      [1] Daly, Ross, Lenny Truong, and Pat Hanrahan. "Invoking and linking generators from multiple hardware languages using coreir." WOSET 2018.
    </div>
  </section>

  <section>
    <h2>2. <span class="green">Mixed Abstraction Design</span>: CIRCT</h2>
    <div class="container" style="grid-template-columns: 1fr 1.0fr; column-gap: 2rem;">
      <div>
        <img class="image" src="/assets/circt-overview-1_nKexNc.svg" />
      </div>
      <div>
        <ul>
          <li class="fragment">The <a href="https://github.com/llvm/circt">CIRCT</a> project 
            <ul>
              <li class="fragment">Dialects for multiple design and intermediate abstractions</li>
              <li class="fragment">Ability to ingest from multiple frontends</li>
              <li class="fragment">Some support for embedding physical design semantics with the design</li>
              <li class="fragment">Cross-dialect interaction (ESI)</li>
              <li class="fragment">A CIRCT-native simulator (Arcilator)</li>
            </ul>
          <li class="fragment">We're exicted to see how CIRCT evolves to support mixed abstraction design</li>
        </ul>
      </div>
    </div>
  </section>

  <section>
    <h2>3. <span class="green">Preserving Semantics</span></h2>
    <ul>
      <li class="fragment">Abstraction-level semantics
        <ul>
          <li class="fragment">Avoid eagerly lowering all abstractions to RTL (for simulation)</li>
          <li class="fragment">Avoid blasting semantics when 'optimizing' RTL
            <ul>
              <li>interfaces, structs, vectors, behavioral constructs, switch statements</li>
            </ul>
          </li>
          <li class="fragment">How do we maintain IR simplicity and ease of pass writing?</li>
        </ul>
      </li>
      <li class="fragment">RTL-level semantics
        <ul>
          <li class="fragment">Synthesis tools shouldn't have to 'reconstruct' designer intent from pattern-matching Verilog (e.g. FSMs)</li>
          <li class="fragment">Potential to improve QoR and runtime</li>
          <li class="fragment">Which circuit primitives should be baked into an IR?</li>
        </ul>
      </li>
    </ul>
  </section>

  <section>
    <h2>3. <span class="green">Preserving Semantics</span></h2>
    <div class="r-stack">
      <img style="object-fit: contain; width: 50%;" class="image fragment fade-in-then-out" data-fragment-index="0" src="/assets/new-paradigm-runtime-interop-Brt92I01.svg" />
      <img style="object-fit: contain; width: 50%;" class="image fragment"                  data-fragment-index="1" src="/assets/elab-interop-1-CjfeopVR.svg" />
    </div>

    <ul style="margin-top: 1rem;">
      <li class="fragment" data-fragment-index="0"><strong>Runtime interop</strong>: how do multiple abstractions interact at runtime?</li>
      <li class="fragment" data-fragment-index="1">Composition of abstractions via elaboration interop</li>
      <li class="fragment" data-fragment-index="2">Edge semantics dictate the semantics of runtime interop</li>
    </ul>
  </section>

  <section>
    <h2>3. <span class="green">Preserving Semantics</span></h2>
    <div class="container" style="grid-template-columns: 1.2fr 1.0fr; column-gap: 2rem;">
      <div class="r-stack">
        <img style="object-fit: contain;" class="image fragment fade-in-then-out" data-fragment-index="0" src="/assets/runtime-interop-1-DHfSO6uQ.svg" />
        <img style="object-fit: contain;" class="image fragment fade-in-then-out" data-fragment-index="1" src="/assets/runtime-interop-2-CIOwk3sV.svg" />
        <img style="object-fit: contain;" class="image fragment fade-in-then-out" data-fragment-index="2" src="/assets/runtime-interop-3-CKQCvN1d.svg" />
        <img style="object-fit: contain;" class="image fragment"                  data-fragment-index="3" src="/assets/runtime-interop-4-HF7Hy55_.svg" />
      </div>
      <div>
        <ul>
          <li class="fragment" data-fragment-index="0"><strong>Runtime interop</strong>: how does time advance between abstraction boundaries?</li>
          <li class="fragment" data-fragment-index="1">Send req (function call)</li>
          <li class="fragment" data-fragment-index="2">RTL advances time</li>
          <li class="fragment" data-fragment-index="3">Runtime interop semantics dictate scheduling the response &amp; updating timing</li>
        </ul>
      </div>
    </div>

    <ul style="margin-top: 1rem;">
      <li class="fragment">Faster simulation throughput than naive cycle-by-cycle updates</li>
      <li class="fragment">Must consider various interface boundary types
        <ul>
          <li>Latency-insensitive interfaces, fixed-latency wires, function calls, etc.</li>
        </ul>
      </li>
    </ul>
  </section>

  <section>
    <h2>3. <span class="green">Preserving Semantics</span></h2>
    <div class="container" style="grid-template-columns: 1.0fr 1.0fr;">
      <div>
        <pre data-id="code-animation"><code class="verilog" data-trim data-line-numbers>
        wire [3:0] uint_val;
        wire [3:0] one_hot;
        wire [3:0] bit_vector;
        </code></pre>
      </div>
      <div>
        <ul>
          <li class="fragment">No distinction between bitvectors and <em>logical integers</em>
            <ul>
              <li class="fragment"><em>logical integer</em> vs <em>physical integer</em></li>
              <li class="fragment">Binary coded, grey coded, one-hot, 2s complement / sign-magnitude</li>
            </ul>
          </li>
        </ul>
      </div>
    </div>

    <ul style="margin-top: 1rem;">
      <li class="fragment">Push more arithmetic types and operations into primitives vs gates
        <ul>
          <li>e.g. floating point, fixed point, intervals, posits</li>
        </ul>
      </li>
      <li class="fragment">Separate <em>logical data types</em> from <em>physical representations</em>
        <ul>
          <li>Let the synthesis tool pick a suitable representation</li>
        </ul>
      </li>
    </ul>
  </section>

  <section>
    <h2>3. <span class="green">Preserving Semantics</span></h2>
    <div class="container" style="grid-template-columns: 1fr 1.0fr;">
      <div>
        <img data-fragment-index=0 style="object-fit: contain;" class="image fragment no-margin" src="/assets/new-paradigm-common-ir-6OdWzItT.svg" />
      </div>
      <div>
        <pre class="fragment" data-id="code-animation"><code class="scala" data-trim data-line-numbers>
        case class Clock
        case class Reset
        case class PriorityMux
        case class UInt(repr=Binary)
        case class UInt(repr=OneHot)
        case class BitVector
        </code></pre>
      </div>
    </div>

    <ul style="margin-top: 1rem;">
      <li class="fragment" data-fragment-index=1><strong>Common IR</strong>: encode circuit-level semantics
        <ul>
          <li>Tunnel semantics from higher abstractions to tools directly</li>
          <li>Backend tools directly operate on the IR (vs Verilog)</li>
        </ul>
      </li>
    </ul>
  </section>
</section>

<!-- -------------------------------------------------------------------- -->

<section>
  <section class="center">
    <h2>Conclusion</h2>

    <div class="container fragment" style="grid-template-columns: 1fr 1fr; column-gap: 2rem;">
      <div>
        <img style="object-fit: contain; height: 220px;" class="image no-margin" src="/assets/current-paradigm-DzqXsLNK.svg" />
      </div>
      <div>
        <img style="object-fit: contain; height: 220px;" class="image no-margin" src="/assets/new-paradigm-HAG3sSfS.svg" />
      </div>
    </div>

    <ul style="margin-top: 1rem;">
      <li class="fragment">Radically rethink the hardware design methodology
        <ol class="smallish">
          <li class="fragment">Rapid iteration cycle across the stack</li>
          <li class="fragment">High productivity hardware design</li>
        </ol>
      </li>
      <li class="fragment">Accomplish this by
        <ol class="smallish">
          <li class="fragment">Incrementalism throughout the language / compiler / simulator / VLSI stack</li>
          <li class="fragment">Seamless mixed-abstraction frontends</li>
          <li class="fragment">Preserving semantics through the design stack</li>
        </ol>
      </li>
    </ul>
  </section>
</section>

<section>
  <section class="center">
    <h2>Backup Slides</h2>

    <p class="center">The source of this presentation can be found here: <a href="https://github.com/vighneshiyer/publications/blob/master/talks/talks/2024_04-latte-the_next_paradigm_of_hw_design.jinja2">https://github.com/vighneshiyer/publications</a></p>
  </section>


  <section class="center">
    <h2>Host decoupling</h2>
    <div class="container" style="grid-template-columns: 1.2fr 1.0fr;">
      <div class="r-stack">
        <img class="fragment fade-in-then-out" data-fragment-index="0" src="/assets/firesim-before-transform-DImWN_El.png"/>
        <img class="fragment fade-in-then-out" data-fragment-index="1" src="/assets/firesim-after-transform-DFvwz_45.png"/>
        <img class="fragment"                  data-fragment-index="2" src="/assets/firesim-mapped-AQwzjdUT.png"/>
      </div>
      <div>
        <font size="5">
        <ul>
        <li class="fragment" data-fragment-index="0">Starting with your target</li>
        <li class="fragment" data-fragment-index="1">Wrap the target RTL in a latency insensitive wrapper</li>
        <li class="fragment" data-fragment-index="1">Attach a DRAM timing model using host FPGA resources</li>
        <li class="fragment" data-fragment-index="1">These steps are automated by the FIRRTL compiler</li>
        <li class="fragment" data-fragment-index="2">Map the simulation onto the host FPGA</li>
        <li class="fragment" data-fragment-index="2">SoC now sees 100 cycles of DRAM latency!</li>
        </ul>
        </font>
      </div>
    </div>
  </section>

  <section class="center">
    <h2>Chipyard Compile Steps</h2>
    <ul>
      <li class="fragment">Scala FIRRTL Compiler (SFC) : Compiles the scala sources and generates CHIRRTL</li>
      <li class="fragment">MLIR FIRRTL Compiler (MFC) : Emits Verilog from CHIRRTL</li>
      <li class="fragment">Verilator : Verilog to C++ binary</li>
    </ul>
  </section>

  <section class="center">
    <h2>Chipyard Compile Steps</h2>
    <div class="container" style="grid-template-rows: 0.1fr 0.7fr;">
      <div>
        <img src="/assets/compile-time-BDWFfH5o.svg" />
      </div>
    </div>
  </section>

  <section class="center">
    <h3>RTL Level IR : Better In Memory Representation</h3>
    <div class="container" style="grid-template-columns: 1.4fr 1.0fr;">
      <div>
        <img src="/assets/rtl-ir-CN6ke9zC.png" style="height: 500px;" class="fragment"/>
      </div>
      <div>
        <font size="5">
        <ul>
          <li class="fragment">Why does this even matter?</li>
          <li class="fragment">The primitives available in your IR affects QoR.</li>
          <li class="fragment">The in memory representation of the circuit affects compiler performance.</li>
          <ul>
            <li class="fragment">Graph representation can affect graph traversal speed. <a href="https://www.hillelwayne.com/post/graph-types/">The hunt for missing datatypes</a></li>
          </ul>
        </ul>
        </font>
      </div>
    </div>
  </section>

  <section data-auto-animate>
    <h3>SSA Rep. Problem</h3>
    <p>FIRRTL's combinational loop detection pass</p>
    <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="1-6|23,27,31|8,13,14,15,18,19|42">
    class CheckCombLoops
        extends Transform
        with RegisteredTransform
        with DependencyAPIMigration {

      ...

      private def getStmtDeps(
        simplifiedModules: mutable.Map[String, AbstractConnMap],
        deps:              MutableConnMap
      )(s:                 Statement
      ): Unit = s match {
        case Connect(info, loc, expr) => ...
        case w: DefWire => ...
        case DefNode(info, name, value) =>
          ...
          getExprDeps(deps, lhs, info)(value)
        case m: DefMemory if (m.readLatency == 0) => ...
        case i: WDefInstance => ...
        case _ => s.foreach(getStmtDeps(simplifiedModules, deps))
      }

      private def run(state: CircuitState) = {
        ...
        topoSortedModules.foreach {
          ...
          case m: Module =>
            val portSet = m.ports.map(p => LogicNode(p.name)).toSet
            val internalDeps = new MutableDiGraph[LogicNode] with MutableEdgeData[LogicNode, Info]
            portSet.foreach(internalDeps.addVertex(_))
            m.foreach(getStmtDeps(simplifiedModuleGraphs, internalDeps))

            moduleGraphs(m.name) = internalDeps
            simplifiedModuleGraphs(m.name) = moduleGraphs(m.name).simplify(portSet)
            // Find combinational nodes with self-edges; this is *NOT* the same as length-1 SCCs!
            for (unitLoopNode &lt;- internalDeps.getVertices.filter(v =&gt; internalDeps.getEdges(v).contains(v))) {
              errors.append(new CombLoopException(m.info, m.name, Seq(unitLoopNode.name)))
            }

            for (scc &lt;- internalDeps.findSCCs.filter(_.length &gt; 1)) {
              val sccSubgraph = internalDeps.subgraph(scc.toSet)
              val cycle = findCycleInSCC(sccSubgraph)
              (cycle.zip(cycle.tail)).foreach({ case (a, b) =&gt; require(internalDeps.getEdges(a).contains(b)) })
              // Reverse to make sure LHS comes after RHS, print repeated vertex at start for legibility
              val intuitiveCycle = cycle.reverse
              val repeatedInitial = prettyPrintAbsoluteRef(Seq(m.name), intuitiveCycle.head)
              val expandedCycle = expandInstancePaths(m.name, moduleGraphs, moduleDeps, Seq(m.name), intuitiveCycle)
              errors.append(new CombLoopException(m.info, m.name, repeatedInitial +: expandedCycle))
            }
          case m => throwInternalError(s"Module ${m.name} has unrecognized type")
        }
        ...
      }
    }
    </code></pre>
    <div class="r-stack">
      <p id="special1" style="transition: all .2s ease; opacity: 0; visibility: hidden; will-change: opacity;">We are traversing the statements to build a graph of the nodes.</p>
      <p id="special2" style="transition: all .2s ease; opacity: 0; visibility: hidden; will-change: opacity;">We are traversing the graph once again to check for comb loops.</p>
    </div>
  </section>

  <section class="center">
    <h3>Graph Rep.</h3>
    <font size="6">
    <div class="container" style="grid-template-columns: 1.0fr 1.0fr;">
      <div>
        <ul>
          <li class="fragment">The above pattern of traversing the graph twice is a very common pattern in FIRRTL passes.</li>
          <li class="fragment">If we had a graph representation of the circuit, we wouldn't have had to traverse the circuit twice.</li>
        </ul>
      </div>
      <div>
        <ul>
          <li class="fragment">Compared to a SSA style, "human readable" IR, debugging passes might become more difficult.</li>
        </ul>
      </div>
    </div>
    </font>
  </section>

  <section class="center">
    <h3>Graph Rep. Implementation Details</h3>
    <div class="container" style="grid-template-columns: 1.0fr 1.4fr;">
      <div>
        <img src="/assets/lgraph-B7CuHK3Z.jpg">
      </div>
      <div>
        <font size="6">
        <ul>
          <li class="fragment">lGraph : high perf. graph based IR.</li>
          <ul>
            <li class="fragment">Hypergraph where each node represents a module and the edges represents the connections.</li>
            <ul>
              <li class="fragment">Submodules forms a graph within a node representing the parent module.</li>
            </ul>
            <li class="fragment">Mmaps disk pages onto virtual memory to reduce memcpy overheads.</li>
            <li class="fragment">Supports graph traversals such that you can access nodes located in adjacent cachelines.</li>
          </ul>
        </ul>
        </font>
      </div>
  </section>

  <section class="center">
    <h3>Graph Rep. Exploiting Parallelism</h3>
    <ul>
      <li class="fragment">Again, the compiler performance is crucial for HW designers : exploit parallelism.</li>
      <li class="fragment">The passes should be written as if it is working on a single thread.</li>
      <ul>
        <li class="fragment">The complexities of dealing with parallelism should be hidden from the pass-writer.</li>
      </ul>
      <li class="fragment">The interpreter (compiler) must be able to partition the graph and execute passes in parallel.</li>
    </ul>
  </section>


  <section class="center">
    <h4>FIRRTL In Memory Representation Problem 2</h4>
    <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers>
    case class Mux(...)
    case class UIntLiteral(...)
    case class SIntLiteral(...)
    case class DefWire(...)
    case class DefRegister(...)
    case class DefInstance(...)
    case class DefMemory(...)
    abstract class PrimOp extends FirrtlNode
    </code></pre>
    <ul>
      <li class="fragment">Limited set of primitives &rarr; QoR may be low.</li>
      <li class="fragment">Compiler & backend tools spends a lot of time recreating semantics.</li>
    </ul>
  </section>

  <section class="center">
    <h4>Possible Primitives</h4>
    <pre data-id="code-animation"><code class="scala" data-trim data-line-numbers="9-12">
    case class Mux(...)
    case class UIntLiteral(...)
    case class SIntLiteral(...)
    case class DefWire(...)
    case class DefRegister(...)
    case class DefInstance(...)
    case class DefMemory(...)
    abstract class PrimOp extends FirrtlNode
    case class OH(...)
    case class PriorityMux(...)
    case class BoolLiteral(...)
    case class DecoupledInterface(...)
    </code></pre>
    <ul>
      <li class="fragment">Add more primitives such that we can preserve more higher level circuit semantics.</li>
      <li class="fragment">Need to find a good balance between pass writing vs QoR.</li>
    </ul>
  </section>

  <section class="center">
    <h4>Miscellaneous : what should be the role of type-systems?</h4>
    <ul>
      <li class="fragment">We all love static types</li>
      <li class="fragment">However, we shouldn't be obsessed by it</li>
      <li class="fragment">Here, we are specifically talking about the types checked in the host language</li>
      <li class="fragment">Things that it should do?
        <ul>
          <li class="fragment">Check connection validity between signals
            <ul>
              <li class="fragment">E.g., you don't want to connect a clock signal into a reset port</li>
            </ul>
          </li>
          <li class="fragment">(For a eDSL), differentiate types between the DSL and host language</li>
          <li class="fragment">Pass physical encodings to the backing compiler and IR
            <ul>
              <li class="fragment">UInt (unsigned integer) vs OneHot (array of wires)</li>
            </ul>
          </li>
                </ul>
      </li>
      <li class="fragment">Things that it shouldn't do?
        <ul>
          <li class="fragment">Shouldn't make the language too verbose</li>
          <li class="fragment">Shouldn't increase the compilation time significantly</li>
          </ul>
      </li>
    </ul>
  </section>

  <section>
    <h2>Design-First vs Spec-First Methodology</h2>

    <!--
    - HW designer oriented approach ("RTL-first" - actually, "design-first, don't model"):
      - Make hardware design fast by being able to write the design directly in multiple abstractions
        - Don't concretize interfaces too early, don't write too many tests early, get the whole system working asap!
        - Once things are a bit mature, then more detailed verification work can begin, but never to the point of building new models
      - Supercharged simulation latency and throughput enable quick bugfix and feature addition turnaround
      - Single source of truth makes it easy to iterate on the design and ISA without rewriting all collateral
      - This works (enabling a small team to produce the best open source IP): Chisel, rocket-chip, BOOM, Chipyard, etc. - existence proof
    - PL researcher oriented approach ("specification to implementation", "correct by construction", "incremental refinement"):
    -->

    <ul>
      <li class="fragment">"Design-first", don't model!
        <ul>
          <li>Enhance productivity with multiple abstractions and fast, low-latency simulation</li>
          <li>Don't specify module interfaces too early - get the whole system working first</li>
          <li>Iterate at the <em>system-level</em> in the <em>early stage</em></li>
        </ul>
      </li>
      <li class="fragment">Single source of truth
        <ul>
          <li>Maintaining models that need to match the RTL creates more problems than it solves</li>
          <li>Iterate on the <em>design directly</em></li>
        </ul>
      </li>
      <li class="fragment">This methodology works
        <ul>
          <li>The "design-first" approach has built robust, high-performance open source RISC-V IP (rocket-chip, BOOM, Hwacha, Chipyard, Constellation) with small teams of grad students</li>
        </ul>
      </li>
      <li class="fragment">The alternatives:
        <ul>
          <li>"Specification to implementation", "Correct by construction", "Incremental refinement"</li>
          <li>We argue: these approaches ensure correctness, but compromise on productivity</li>
        </ul>
      </li>
      <p class="center fragment"><strong>"Spec-first" and "design-first" methodologies need to meet in the middle</strong></p>
    </ul>

  </section>

  <section class="center">
    <h2>HW Accelerated Simulation</h2>
    <ul>
      <li class="fragment">HW accelerated RTL simulation is receiving more attention recently
        <ul>
          <li>FireSim, Parendi, Manticore, MIT emulator etc</li>
        </ul>
      </li>
      <li class="fragment">Main focus of these platforms are in simulation throughput</li>
      <li class="fragment">Simulation build time is also crucial
        <ul>
          <li>Especially during the initial phase of the design</li>
        </ul>
      </li>
      <li class="fragment">Direct FPGA simulation (FireSim) &rarr; partial reconfiguration
        <ul>
          <li>Limited in resources, flexibility and speed</li>
        </ul>
      </li>
      <li class="fragment">FPGA overlayed emulation &rarr; partial comp. + caching
        <ul>
          <li>Only have to rebuild the software (no FPGA tools involved)</li>
          <li>Fixes aren't limited by the FPGA partial-reconfig region</li>
          <li>Better option for initial iteration phase when combined with partial compilation and caching</li>
        </ul>
      </li>
    </ul>


  </section>

</section>

        </div>
    </div>

  </body>
</html>