<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>SimCommand: A High-Performance RTL Testbench API with Fork/Join Support</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/white.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
    <style>
      .container{
        display: grid;
        grid-auto-flow: column;
        column-gap: 1em;
      }
/*
.container{
  display: flex;
}
.col {
  flex: 1;
}
  */

      .reveal pre {
        width: 100%;
      }
      .reveal pre code {
        padding: 20px;
      }

      .small {
        font-size: 0.8em;
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
      <section>
        <section>
          <div style="display:grid; align-items:center; grid-template-columns: 1fr 1fr;">
            <div style="display:grid; place-items:center;"><img src="./figs/berkeley_logo.svg" height="100px" /></div>
            <div style="display:grid; place-items:center;"><img src="./figs/slice_logo.png" height="100px" /></div>
          </div>
          <h2 style="text-transform:none;">SimCommand: A High Performance RTL Testbench API with Fork/Join Support</h2>
          <p><strong>Vighnesh Iyer</strong>, Young-Jin Park</p>
          <p>Latch-Up 2023</p>
        </section>

        <section>
            <h2>Writing Testbenches</h2>
            <p class="center fragment">After writing RTL, you write a testbench!</p>
            <p class="center fragment">To make this productive, we want:</p>
            <ul>
              <li class="fragment">Comprehensive standard library</li>
              <li class="fragment">Package / dependency manager</li>
              <li class="fragment">Unit testing library</li>
              <li class="fragment">IDE</li>
            </ul>
        </section>

        <section>
            <h2>Existing Solutions</h2>
            <ul class="small">
              <li>Comprehensive standard library</li>
              <li>Package / dependency manager</li>
              <li>Unit testing library</li>
              <li>IDE</li>
            </ul>

            <ul>
              <li class="fragment"><em>Verilog ecosystem</em>: FuseSoC, VUnit</li>
              <li class="fragment"><em>C++ ecosystem</em>: std, CMake, CLion</li>
              <li class="fragment"><em>Python ecosystem</em>: pip, pytest, PyCharm</li>
            </ul>

            <p class="fragment">While Verilog is ok, we really want to write testbenches in a general-purpose programming language</p>
        </section>

        <section>
            <h2>Testbench APIs in General Purpose Languages</h2>
            <ul class="fragment">
              <li>Scala: chiseltest</li>
              <li>Python: cocotb</li>
            </ul>

            <p class="fragment">Both provide all the benefits of being in a general-purpose language, <em>while having fork/join primitives</em></p>
            <p class="fragment">However, their fork/join functionality <strong>is slow</strong></p>
            <p class="fragment">We shouldn't have to compromise on performance</p>
        </section>

        <section>
            <h2>SimCommand</h2>
            <ul>
              <li class="fragment">Testbench API embedded in Scala</li>
              <li class="fragment">Uses chiseltest as the simulator interface</li>
              <li class="fragment">Purely functional: testbench description and interpretation are split</li>
            </ul>

            <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
  def enqueue(data: T): Command[Unit] = for {
    _ <- poke(io.bits, data)
    _ <- poke(io.valid, true.B)
    _ <- waitUntil(io.ready, true.B)
    _ <- step(1)
    _ <- poke(io.valid, false.B)
  } yield ()
            </pre></code>
    </section>

          <section>
            <h3>Fork/Join</h3>
            <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
val pushNPop: Command[Boolean] = for {
    enqThread <- fork(enqueue(100.U))
    deqThread <- fork(dequeue())
    _         <- join(enqThread)
    data      <- join(deqThread)
} yield data.litValue == 100</pre></code>

            <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
test(new Queue(UInt(8.W), 4)) { c =>
  val allGood = run(pushNPop, c.clock)
  assert(allGood)
}</pre></code>
          </section>

          <section>
            <h3>Interpreter / Scheduler</h3>
            <div class="container" style="grid-template-columns: 1fr 1fr;">
              <div class="col" style="display: grid;">
                <img src="./figs/OSCAR_thread_figure.png" style="align-self:center;" />
              </div>
              <div class="col">
                <ul>
                  <li class="fragment">On each timestep
                    <ul class="small">
                      <li>Run every thread until a step, join, or return</li>
                      <li>Collect any new threads spawned</li>
                      <li>Repeat until a fixpoint is reached</li>
                    </ul>
                  </li>
                  <li class="fragment">Step the clock</li>
                  <li class="fragment">Repeat until the main thread returns</li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <h3>Performance Benchmarks</h3>
            <table style="font-size: 0.7em;">
              <thead>
                <tr>
                  <th style="width:35%;">Platform</th>
                  <th colspan="2">DecoupledGCD</th>
                  <th colspan="2">NeuromorphicProcessor</th>
                </tr>
              </thead>
              <tbody>
                <tr class="fragment" data-fragment-index="2">
                  <td>SystemVerilog + commercial simulator</td>
                  <td>0.40 s</td>
                  <td>412 kHz</td>
                  <td>0:30 min</td>
                  <td>1.8 MHz</td>
                </tr>
                <!--<tr>
                  <td>Chiseltest with manual thread interleaving</td>
                  <td>0.75 s</td>
                  <td>220 kHz</td>
                  <td>2:03 min</td>
                  <td>432 kHz</td>
                </tr>-->
                <tr class="fragment" data-fragment-index="1">
                  <td><strong>Chiseltest with Command API</strong></td>
                  <td><strong>2.4 s</strong></td>
                  <td><strong>67 kHz</strong></td>
                  <td><strong>0:06 min</strong></td>
                  <td><strong>53 MHz</strong></td>
                </tr>
                <tr>
                  <td>Chiseltest with fork/join threading</td>
                  <td>21 s</td>
                  <td>7.8 kHz</td>
                  <td>27:21 min</td>
                  <td>33 kHz</td>
                </tr>
                <tr>
                  <td>cocotb</td>
                  <td>43.2 s</td>
                  <td>3.8 kHz</td>
                  <td>89:38 min</td>
                  <td>10 kHz</td>
                </tr>
              </tbody>
            </table>
            <p class="fragment"><strong>17x</strong> faster than cocotb, <strong>5x</strong> faster than chiseltest</p>
          </section>

          <section>
            <h3>Conclusion</h3>
            <p class="fragment small">SimCommand makes writing system-level tests using Scala viable.</p>
            <p class="fragment small">This technique is applicable to testbench APIs in other host languages.</p>
            <div class="fragment">
              <p>More stuff:</p>
              <ul class="small">
                <li>Channels for inter-thread communication</li>
                <li>Debug APIs, thread tracing</li>
                <li>RTL-free VIP unit testing</li>
                <!--<li>TileLink / AXI VIPs</li>-->
                <!--<li>Performance parity with SystemVerilog</li>-->
                <!--<li>Race condition elimination via ‘determinism by replay’</li>-->
              </ul>
            </div>
            <p class="fragment"><a href="https://github.com/vighneshiyer/simcommand">github.com/vighneshiyer/simcommand</a></p>
          </section>

        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,
        transition: 'slide', // none
        transitionSpeed: 'fast',
        slideNumber: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
      });
      Reveal.configure({ pdfSeparateFragments: false });
    </script>
  </body>
</html>
