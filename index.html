<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>A High-Performance Multithreaded RTL Testbench API</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/white.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
    <style>
      .container{
        display: grid;
        grid-auto-flow: column;
        column-gap: 1em;
      }
/*
.container{
  display: flex;
}
.col {
  flex: 1;
}
  */

      .reveal pre {
        width: 100%;
      }
      .reveal pre code {
        padding: 20px;
      }

      .small {
        font-size: 0.8em;
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <!--<div class="slice_logo" style="position:absolute; top:60px; left:100px;">
          <img src="./figs/slice_logo.png" width="200px"/>
      </div>-->
      <div class="slides">
        <section>
          <img src="./figs/slice_logo.png" width="40%"/>
          <h2>A High Performance Multi-Threaded RTL Testbench API</h2>
          <p><b>Vighnesh Iyer</b>, Kevin Laeufer, Bora Nikolic</p>
          <p>SLICE Retreat - Summer 2022</p>
        </section>
        <section>
          <section>
            <h2>Background and Motivation</h2>
          </section>

          <section>
            <h3>Testbench APIs</h3>
            <ul>
              <li class="fragment">The interface between <i>testbench logic</i> and a <i>simulator backend</i></li>
              <ul>
                <li class="fragment"><b>Simulator backends</b>: Verilator, Icarus, VCS</li>
                <div class="fragment">
                  <li><b>Native Testbench APIs</b></li>
                  <ul>
                    <li>SystemVerilog</li>
                    <li>C++ (with Verilator headers)</li>
                  </ul>
                </div>
                <div class="fragment">
                  <li><b>General-Purpose Testbench APIs</b></li>
                  <ul>
                    <li>cocotb (Python)</li>
                    <li>chiseltest (Scala)</li>
                  </ul>
                </div>
              </ul>
            </ul>
          </section>

          <section>
            <h3>Testbench API Primitives</h3>
            <p class="small">For synchronous single-clock RTL</p>
            <p>All APIs support concepts of <code>poke</code>, <code>peek</code>, and <code>step</code></p>
            <!--<p>Consider a FIFO and its enqueuing ready-valid interface</p> -->
              <pre><code data-trim data-noescape>
              module fifo (input clk, enq_valid,
                           input [31:0] enq_data,
                           output enq_ready);
              </code></pre>

              <div class="r-stack">
                <pre class="fragment fade-out" data-fragment-index="0"><code class="language-verilog" data-trim data-noescape>
// SystemVerilog

enq_valid = 1'b1; // poke
enq_data = 'd100;
while(enq_ready != 1'b1) begin // peek
  @(posedge clk); // step
end
@(posedge clk);
enq_valid = 1'b0;
                </code></pre>
                <pre class="fragment current-visible" data-fragment-index="0"><code class="language-python" data-trim data-noescape>
# cocotb

dut.enq_valid.value = 1 # poke
dut.enq_data.value = 100
while dut.input_ready.value != 1: # peek
    await RisingEdge(dut.clock) # step
await RisingEdge(dut.clock)
dut.enq_valid.value = 0
                </code></pre>
                <pre class="fragment"><code class="language-scala" data-trim data-noescape>
// chiseltest

dut.enq_valid.poke(1)
dut.enq_data.poke(100)
while (dut.input_ready.peek().litValue != 1) {
  dut.clock.step()
}
dut.clock.step()
dut.enq_valid.poke(0)
                </code></pre>
              </div>
          </section>

          <section>
            <h3>Driving Two Interfaces Simultaneously</h3>
            <pre><code data-trim data-noescape>
            module example (input clk, input [31:0] a, input [31:0] b);
            </code></pre>
            <div class="container">
              <div class="col fragment">
                <pre><code class="language-scala small" data-trim data-noescape>
a.poke(1)
clk.step(4)
a.poke(2)
                </code></pre>

              </div>
              <div class="col fragment">
                <pre><code class="language-scala small" data-trim data-noescape>
b.poke(100)
clk.step(2)
b.poke(200)
clk.step(4)
b.poke(300)
                </code></pre>
              </div>
            </div>
            <p class="fragment">We want to run both code segments in parallel, synchronized on clock edges.</p>
          </section>

          <section data-visibility="hidden">
            <h3>Manual Thread Interleaving</h3>
            <div class="container">
              <div class="col fragment">
                <pre><code class="language-verilog small" data-trim data-noescape>
// Two code segments

a.poke(1)
clk.step(4)
a.poke(2)

---

b.poke(100)
clk.step(2)
b.poke(200)
clk.step(4)
b.poke(300)
                </code></pre>
              </div>
              <div class="col fragment">
                <pre><code class="language-verilog small" data-trim data-noescape>
// Interleaved

a.poke(1)
b.poke(100)
clk.step(2)

b.poke(200)
clk.step(2)

a.poke(2)
clk.step(2)

b.poke(300)
                </code></pre>
              </div>
            </div>
            <p class="fragment">No reusability, prone to bugs</p>
          </section>

          <section>
            <h3>Thread Interleaving with SW FSMs</h3>
            <div class="container">
              <div class="col fragment">
                <pre><code class="language-scala small" data-trim data-noescape>
trait Thread {
    def step(): Unit
    def done(): Boolean
}
class a extends Thread {
    var cycle = 0
    def step() = {
        if (cycle == 0)
            dut.a.poke(1.U)
        else if (cycle >= 4)
            dut.a.poke(2.U)
        cycle = cycle + 1
    }
    def done() = (cycle == 5)
}
                </code></pre>
              </div>
              <div class="col fragment">
                <pre><code class="language-scala small" data-trim data-noescape>
val threads = Seq(a(), b())
while (!threads.all(_.done))
    threads.forEach(_.step())
                </code></pre>
                <ul>
                  <li class="fragment">Step each thread until they are all done</li>
                  <li class="fragment">Can emulate any simulation threading scenario</li>
                  <li class="fragment">Reusable</li>
                  <li class="fragment">Painful to write / debug</li>
                </ul>
              </div>
            </div>


          </section>

          <section>
            <h3>Fork/Join</h3>
            <p><code>fork/join</code> is a universal primitive to express testbench logic parallelism</p>
            <div class="container">
              <div class="col">
                <pre><code class="language-scala small" data-trim data-noescape>
val a = fork {
    a.poke(1.U)
    clk.step(4)
    a.poke(2.U)
}
val b = fork {
    b.poke(100.U)
    clk.step(2)
    b.poke(200.U)
    clk.step(4)
    b.poke(300.U)
}
a.join
b.join
                </code></pre>
              </div>
              <div class="col">
                <ul>
                  <li class="fragment">fork spawns a simulation thread
                  <li class="fragment">join blocks until the child thread is done</li>
                    <!--<ul class="small"><li>returns a handle that can be ‘join’ed later</li></ul>-->
                  </li>
                  <li class="fragment">Threads are synchronized on clock steps
                    <ul class="small">
                      <li>Once the main thread steps, all child threads are advanced until they step</li>
                      <!--<li>Advance a cycle in the RTL simulator</li>-->
                      <!--<li>Repeat until main thread ends</li>-->
                    </ul>
                  </li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <h3>Chiseltest Implementation</h3>
            <ul>
              <li class="fragment">Fork-ing a simulation thread, spawns a <em>new</em> JVM thread</li>
              <li class="fragment">On every timestep, the chiseltest scheduler runs each thread, one at a time
                <ul class="small">
                  <li>Each thread can:
                    <ul>
                      <li>Terminate</li>
                      <li>Peek / Poke</li>
                      <li>Fork new threads</li>
                      <li>Yield (step or join)</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li class="fragment">Parking and unparking threads on a single executor is <strong>slow</strong></li>
            </ul>
          </section>

          <section>
            <h3>Overhead of Sim Threads</h3>
            <p class="fragment">DecoupledGCD testbench benchmark</p>
            <table class="small fragment">
              <thead>
                <tr>
                  <th>Platform</th>
                  <th>Throughput</th>
                  <th>Slowdown</th>
                </tr>
              </thead>
              <tbody>
                <!--<tr>
                  <td>SystemVerilog + commercial simulator</td>
                  <td>412 kHz</td>
                  <td>-</td>
                </tr>-->
                <tr>
                  <td>Chiseltest with manual thread interleaving</td>
                  <td>220 kHz</td>
                  <!--<td>1.9x</td>-->
                  <td>-</td>
                </tr>
                <tr>
                  <td>Chiseltest with fork/join threading</td>
                  <td>7.8 kHz</td>
                  <!--<td>53x</td>-->
                  <td>28x</td>
                </tr>
                <!--<tr>
                  <td>cocotb</td>
                  <td>3.8 kHz</td>
                  <td>108x</td>
                  <td>58x</td>
                </tr>-->
              </tbody>
            </table>

            <p style="margin-top:30px;" class="small fragment">The overhead of simulation threads in chiseltest is too high.</p>
            <p class="small fragment">Is there a way to bypass the JVM thread switching overhead?</p>
          </section>
        </section>

        <section>
          <section>
            <h2>Designing a New API</h2>
          </section>

          <section>
            <h3>Specification</h3>

            <div class="fragment">
              <p><b>Desires</b></p>
              <ol class="small">
                <li>Faster than existing chiseltest runtime</li>
                <li>Supports threading via fork/join semantics</li>
                <li>Nearly as user friendly as writing imperative code</li>
              </ol>
            </div>

            <div class="fragment">
              <p><b>Implications</b></p>
              <ol class="small">
                <li>Do not spawn any JVM threads or multiplex them</li>
                <li>The scheduler needs to pause and resume user testbench threads</li>
                <li>Writing user threads should be like writing a sequence of simulation commands</li>
              </ol>
            </div>
          </section>

          <section>
            <h3>A Functional Datatype</h3>
            <p><strong>FP principle</strong>: Separate description from interpretation</p>
            <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
sealed trait Command[R] // R is the return type of running the Command
case class Peek[I <: Data](signal: I) extends Command[I]
case class Poke[I <: Data](signal: I, value: I) extends Command[Unit]
case class Step(cycles: Int) extends Command[Unit]
            </pre></code>
            <ul class="fragment">
              <li>Instantiating these classes doesn’t <em>do anything</em></li>
              <li>They only <em>describe</em> the actions of peeking, poking, or stepping</li>
              <li>An <em>interpreter</em> actually runs the actions</li>
            </ul>
          </section>

          <section>
            <h3>Usage Example</h3>
            <pre><code class="language-scala small" data-trim data-noescape>
test(new Queue(UInt(32.W), 16)) { dut =>
    val poker   : Command[Unit] = Poke(dut.enq.valid, 1.B)
    val stepper : Command[Unit] = Step(1)
    val peeker  : Command[UInt] = Peek(dut.deq.valid)
}
            </pre></code>
            <p class="fragment"><code>poker</code>, <code>stepper</code>, <code>peeker</code> don't <em>do</em> anything</p>
            <p class="fragment">How can we use the value of a previous command in a subsequent one?</p>
          </section>

          <section>
            <h3>Command Continuations</h3>
            <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
case class Return[R](retval: R) extends Command[R]
case class Cont[R1, R2](c: Command[R1], then: R1 => Command[R2]) extends Command[R2]
            </pre></code>
            <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
def flatMap[R1, R2](c: Command[R1], f: R1 => Command[R2]): Command[R2] = {
  c match {
    case Return(retval) => f(retval)
    case cmd: Command[R1] => Cont(cmd, f)
  }
}
            </pre></code>
            <p class="fragment">Now, we can describe executing a command after another</p>
          </section>

          <section>
            <h3>A Sequence of Commands</h3>
            <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
val program: Command[Boolean] =
  Poke(dut.enq.valid, 1.B).flatMap {
    _ => Step(1).flatMap {
      _ => Peek(dut.deq.valid).map {
        p => p.litValue == 1
      }
    }
  }
            </pre></code>
            <img class="fragment" src="./figs/command_sequencing.svg"/>
          </section>

          <section>
            <h3>Scala For-Comprehension Sugar</h3>
            <div class="container">
              <div class="col">
                <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
val program: Command[Boolean] =
  Poke(dut.enq.valid, 1.B).flatMap {
    _ => Step(1).flatMap {
      _ => Peek(dut.deq.valid).map {
        p => p.litValue == 1
      }
    }
  }
                </pre></code>
              </div>
              <div class="col">
                <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
val program: Command[Boolean] = for {
    _ <- Poke(dut.enq.valid, 1.B)
    _ <- Step(1)
    p <- Peek(dut.deq.valid)
} yield p.litValue == 1
                </pre></code>
              </div>
            </div>
            <p class="fragment">Now, we can describe sequential programs that <em>look</em> like imperative code</p>
          </section>

          <section>
            <h3>A Recursive Interpreter</h3>
            <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
def run(c: Command[R], clock: Clock): R = {
    c match {
        Peek(signal) => signal.peek() // same for poke, step
        Return(retval) => retval
        Cont(c1, c2) =>
          val r = run(c1, clock)
          run(c2(r), clock)
    }
}
            </pre></code>

            <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
test(new Queue(UInt(32.W), 16)) { dut =>
    val allGood = run(program, dut.clock)
    assert(allGood)
}
            </pre></code>
          </section>

          <section>
            <h3>Command Interpretation</h3>
            <img src="./figs/command_interpretation.svg"/>
            <p class="fragment">The interpreter has full control of a thread</p>
            <p class="small fragment">A 'thread' is just a pointer to a <code>Command</code></p>
          </section>

          <section>
            <h3>Command Combinators</h3>
            <p>Commands are values → can be manipulated by ordinary functions</p>
            <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
// Repeats a command n times
def repeat(cmd: Command[_], n: Int): Command[Unit]

// Run a list of programs sequentially
def concat[R](cmds: Seq[Command[R]]): Command[Unit]

// Run a list of programs and aggregate their results
def sequence[R](cmds: Seq[Command[R]]): Command[Seq[R]]
            </pre></code>
          </section>

          <section>
            <h3>Looping Commands</h3>
            <p>Library of stack-safe functions that emulate imperative loops</p>
            <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
// Run this program until it returns false
def doWhile(cmd: Command[Boolean]): Command[Unit]

// Run this program continuously
def forever(cmd: Command[_]): Command[Nothing]
            </pre></code>
            <!--def while(cond: Command[Boolean], action: Command[_]): Command[Unit]-->

            <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
// Step the clock until the signal == value
def waitUntil[I <: Data](signal: I, value: I): Command[Unit]
            </pre></code>
          </section>

          <section data-visibility="hidden">
            <h3>UART TX Example</h3>
            <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
  def sendBit(bit: Int): Command[Unit] = {
    for {
      _ <- poke(uartIn, bit.B)
      _ <- step(cyclesPerBit)
    } yield ()
  }
            </pre></code>

            <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
  def sendByte(byte: Int): Command[Unit] = {
    for {
      _ <- sendBit(0)
      _ <- concat((0 until 8).map(i => sendBit((byte >> i) & 0x1)))
      _ <- sendBit(1)
    } yield ()
  }
            </pre></code>
            <p class="fragment">For-loops → list of function invocations</p>
          </section>

          <section>
            <h3>Ready-Valid Example</h3>
            <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
  def enqueue(data: T): Command[Unit] = for {
    _ <- poke(io.bits, data)
    _ <- poke(io.valid, true.B)
    _ <- waitUntil(io.ready, true.B)
    _ <- step(1)
    _ <- poke(io.valid, false.B)
  } yield ()
            </pre></code>
            <!--
            <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
  def dequeue(): Command[T] = for {
    _ <- waitForValue(io.valid, true.B)
    _ <- poke(io.ready, true.B)
    value <- peek(io.bits)
    _ <- step(1)
  } yield value
            </pre></code>
            -->
            <p class="fragment">Equivalent functionality to imperative implementation</p>
          </section>
        </section>

        <section>
          <section>
            <h2>Simulation Threading and Scheduling</h2>
          </section>

          <section>
            <h3>Fork/Join</h3>
            <!--<pre class="fragment"><code class="language-scala small" data-trim data-noescape>
def fork[R](c: Command[R]): Command[ThreadHandle[R]]
def join[R](c: ThreadHandle[R]): Command[R]
            </pre></code>-->

            <pre class="fragment"><code class="language-scala small" data-trim data-noescape>
val queueTest: Command[Boolean] = for {
    enqThread <- fork(enqueue(100.U))
    deqThread <- fork(dequeue())
    _         <- join(enqThread)
    data      <- join(deqThread)
} yield data.litValue == 100
            </pre></code>
          </section>

          <section>
            <h3>Interpreter / Scheduler</h3>
            <div class="container" style="grid-template-columns: 1fr 1fr;">
              <div class="col" style="display: grid;">
                <img src="./figs/OSCAR_thread_figure.png" style="align-self:center;" />
              </div>
              <div class="col">
                <ul>
                  <li class="fragment">On each timestep
                    <ul class="small">
                      <li>Run every thread until a step, join, or return</li>
                      <li>Collect any new threads spawned</li>
                      <li>Repeat until a fixpoint is reached</li>
                    </ul>
                  </li>
                  <li class="fragment">Step the clock</li>
                  <li class="fragment">Repeat until the main thread returns</li>
                </ul>
              </div>
            </div>
          </section>
        </section>

        <section>
          <section>
            <h2>Results</h2>
          </section>

          <section>
            <h3>Performance Benchmarks</h3>
            <table style="font-size: 0.7em;">
              <thead>
                <tr>
                  <th style="width:35%;">Platform</th>
                  <th colspan="2">DecoupledGCD</th>
                  <th colspan="2">NeuromorphicProcessor</th>
                </tr>
              </thead>
              <tbody>
                <tr class="fragment" data-fragment-index="2">
                  <td>SystemVerilog + commercial simulator</td>
                  <td>0.40 s</td>
                  <td>412 kHz</td>
                  <td>0:30 min</td>
                  <td>1782 kHz</td>
                </tr>
                <tr>
                  <td>Chiseltest with manual thread interleaving</td>
                  <td>0.75 s</td>
                  <td>220 kHz</td>
                  <td>2:03 min</td>
                  <td>432 kHz</td>
                </tr>
                <tr class="fragment" data-fragment-index="1">
                  <td>Chiseltest with <strong>Command API</strong></td>
                  <td>2.4 s</td>
                  <td>67 kHz</td>
                  <td>5:23 min</td>
                  <td>165 kHz</td>
                </tr>
                <tr>
                  <td>Chiseltest with fork/join threading</td>
                  <td>21 s</td>
                  <td>7.8 kHz</td>
                  <td>27:21 min</td>
                  <td>32.6 kHz</td>
                </tr>
                <tr>
                  <td>cocotb</td>
                  <td>43.2 s</td>
                  <td>3.8 kHz</td>
                  <td>89:38 min</td>
                  <td>9.9 kHz</td>
                </tr>
              </tbody>
            </table>
          </section>

          <section>
            <h3>Conclusion</h3>
            <p class="fragment">Encoding simulation commands as values enables a fast runtime using only 1 thread.</p>
            <p class="fragment">Fastest general-purpose testbench API with simulation threading support.</p>
            <div class="fragment">
              <p>Coming up:</p>
              <ul class="small">
                <li>Channels for inter-thread communication</li>
                <li>Better debug (macros, prints)</li>
                <li>TileLink VIPs</li>
                <li>Perf parity with SystemVerilog</li>
                <!--<li>Race condition elimination via ‘determinism by replay’</li>-->
              </ul>
            </div>
            <p class="fragment"><a href="https://github.com/vighneshiyer/simcommand">github.com/vighneshiyer/simcommand</a></p>
          </section>

        </section>

        <section>
          <section>
            <h3>Discussion</h3>
          </section>

          <section>
            <h3>Better Benchmarks?</h3>
            <p>Requirements:</p>
            <ul>
              <li>Simple (but large), single-clock blob of Verilog RTL</li>
              <li>Simple top-level IOs for VIP implementation</li>
              <li>Simple checker</li>
              <li>Long running test with simple stimulus generation</li>
            </ul>
            <p class="fragment">Ideas: BaseTile (Rocket/BOOM), NoC</p>
            <p class="fragment">Also: measure # threads vs throughput</p>
          </section>

          <section>
            <h3>How to Improve Performance?</h3>
            <ul>
              <li>Imperative interpreter with internal mutable state</li>
              <li>FFI overhead to Verilator .so using JNI vs JNA</li>
              <li>Skip through cycles of no IO activity</li>
            </ul>
            <p class="fragment">Q: what is the overhead of UVM over baseline SV?</p>
            <p class="fragment">Q: when profiling a typical block-level simulation, where is time spent?</p>
          </section>

          <section>
            <h3>Attaching Verification Collateral</h3>
            <ul>
              <li>Top-level monitors</li>
              <li>Internal bus monitors (TileLink, Decoupled, Irrevocable)</li>
              <li>Golden models</li>
            </ul>
            <div class="fragment">
              <p>Q: how are internal bus monitors usually implemented?</p>
              <p class="small">(RTL, SV models with binds) (separate read-only thread?)</p>
            </div>
          </section>

          <section>
            <h3>How to Handle Race Conditions</h3>
            <h4>Same Port Races</h4>
            <div class="container fragment">
              <div class="col">
                <pre><code class="language-scala small" data-trim data-noescape>
  def enqueue(data: T) = for {
    _ <- poke(io.bits, data)
    _ <- poke(io.valid, true.B)
    _ <- waitUntil(io.ready, true.B)
    _ <- step(1)
    _ <- poke(io.valid, false.B)
  } yield ()
                </pre></code>
              </div>
              <div class="col">
                <pre><code class="language-scala small" data-trim data-noescape>
  def dequeue() = for {
    _ <- waitForValue(io.valid, true.B)
    _ <- poke(io.ready, true.B)
    value <- peek(io.bits)
    _ <- step(1)
  } yield value
                </pre></code>
              </div>
            </div>
            <p class="fragment small">When both of these are used on a single port to drive and monitor, there is a race</p>
            <p class="fragment small">SV resolves this using blocking vs non-blocking assigns and reads</p>
            <p class="fragment">Q: is having a 'monitor' region the right approach?</p>
          </section>

          <section>
            <h3>Schedulers</h3>
            <div class="container">
              <div class="col">
                <img src="figs/systemverilog_scheduling_semantics.png" />
              </div>
              <div class="col">
                <ul class="small">
                  <li>Active region: Execute all blocking and continuous assignments</li>
                  <li>NBA region: Execute all non-blocking assignments (FF + testbench code)</li>
                  <li>Observed region: Evaluate concurrent assertions</li>
                  <li>Reactive region: Evaluate program blocks</li>
                </ul>
              </div>
            </div>
            <p class="fragment">Q: Is this complexity necessary? Can it be generalized?</p>
          </section>

          <section>
            <h3>How to Handle Race Conditions</h3>
            <h4>Comb Loop Races</h4>
            <img src="figs/comb_loop_race.svg" />
            <p class="fragment">Thread order determines behavior - unspecified in SystemVerilog</p>
            <p class="fragment small">How often does this occur in practice? How is it resolved?</p>
          </section>

          <section>
            <h3>DUT Interaction Methods</h3>
            <p>RTL Transactors vs C++ cycle-by-cycle drivers vs SV VIPs</p>
            <ul>
              <li class="fragment">Q: When are each of them used?</li>
              <li class="fragment">Q: What are the limitations of transactors?</li>
              <li class="fragment">Q: Is there a unified way to design them?</li>
              <li class="fragment">Q: Are the transactions portable?</li>
            </ul>
          </section>

          <section>
            <h3>Hardware Modeling</h3>
            <p>Can the same constructs used for testbenches be used for hardware modeling?</p>
            <p class="small">SystemC uses modules, channels / ports, events, and processes</p>
            <ul>
              <li class="fragment">Q: Is SystemC often used as testbench top vs SystemVerilog?</li>
              <li class="fragment">Q: What are the benefits for unifying hardware modeling and testbench code?</li>
              <li class="fragment">Q: Can a subset of SystemC code be turned into a formal transaction-level model?</li>
            </ul>
          </section>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,
        transition: 'slide', // none
        transitionSpeed: 'fast',
        slideNumber: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
      });
      Reveal.configure({ pdfSeparateFragments: false });
    </script>
  </body>
</html>
